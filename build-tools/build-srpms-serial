#!/bin/bash
# set -x

CMDLINE="build-srpms-serial $@"

DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
source $DIR/spec-utils
source $DIR/srpm-utils
source $DIR/classify

INITIAL_DIR=`pwd`
export DISTRO="centos"
SRPM_SCRIPT="build_srpm"
SRPM_DATA="build_srpm.data"
PKG_DIRS_FILE=centos_pkg_dirs

DEFAULT_SRPM_SCRIPT="$DIR/default_$SRPM_SCRIPT"
SCRIPT_PATH="$DISTRO"
DATA_PATH="$DISTRO"
FILES_PATH="$DISTRO/files"
PATCHES_PATH="$DISTRO/patches"
ORIG_SPECS_PATH="$DISTRO"
SRPM_LIST_PATH="$DISTRO/srpm_path"
MIRROR_ROOT="$MY_REPO/cgcs-centos-repo"
THIRD_PARTY_ROOT="$MY_REPO/cgcs-3rd-party-repo"
REPO_DOWNLOADS_ROOT="$MY_REPO"
SRPM_REBUILT_LIST=""
SRPM_FAILED_REBUILD_LIST=""

CREATEREPO=$(which createrepo_c)
if [ $? -ne 0 ]; then
   CREATEREPO="createrepo"
fi

usage () {
    echo ""
    echo "Usage: "
    echo "   Create source rpms:"
    echo "      build-srpms [--rt | --std | --installer] [--no-descendants] [--formal] [ list of package names ]"
    echo ""
    echo "   Delete source rpms, and the directories associated with it's creation:"
    echo "   Note: does not clean an edit environment"
    echo "      build-srpms --clean [--rt | --std | --installer] [optional list of package names]"
    echo ""
    echo "   Extract an src.rpm into a pair of git trees to aid in editing it's contents,"
    echo "   one for source code and one for metadata such as the spec file."
    echo "   If --no-meta-patch is specified, then WRS patches are omitted."
    echo "      build-srpms --edit [--rt | --std | --installer] [--no-meta-patch] [list of package names]"
    echo ""
    echo "   Delete an edit environment"
    echo "      build-srpms --edit --clean [--rt | --std | --installer] [list of package names]"
    echo ""
    echo "   This help page"
    echo "      build-srpms --help"
    echo ""
}

# This function creates a bunch of subdirs in $MY_WORKSPACE and makes sure
# that a $MY_BUILD_CFG file exists.
#
# The goal of this is to have a script do as much of the annoying
# grunt-work so that the "how to build it" instructions aren't 200 lines
create_output_dirs () {
	# make sure variables are sane before continuing
	# Note that $BUILD_ROOT contains either $MY_WORKSPACE or $MY_PATCH_WORKSPACE
	if [ "x$BUILD_ROOT" == "x" ]; then
		return
	fi
	if [ "x$MY_BUILD_CFG" == "x" ]; then
		return
	fi
	if [ "x$MY_BUILD_DIR" == "x" ]; then
		return
	fi
	if [ "x$MY_SRC_RPM_BUILD_DIR" == "x" ]; then
		return
	fi

	# create output dirs
	mkdir -p $MY_BUILD_DIR
	mkdir -p $MY_SRC_RPM_BUILD_DIR
	mkdir -p $MY_SRC_RPM_BUILD_DIR/SOURCES
	mkdir -p $MY_SRC_RPM_BUILD_DIR/SPECS
	mkdir -p $MY_SRC_RPM_BUILD_DIR/BUILD
	mkdir -p $MY_SRC_RPM_BUILD_DIR/RPMS
	mkdir -p $MY_SRC_RPM_BUILD_DIR/SRPMS

	# create $MY_BUILD_CFG, if required
	if [ ! -f $MY_BUILD_CFG ]; then
           echo "FORMAL_BUILD=$FORMAL_BUILD"
           echo "modify-build-cfg $MY_BUILD_CFG"
           ${DIR}/modify-build-cfg $MY_BUILD_CFG
           if [ $? -ne 0 ]; then
               echo "Could not modifiy $MY_BUILD_CFG";
               exit 1
           fi
	fi

}

NO_DESCENDANTS=0
NO_BUILD_INFO=0
HELP=0
CLEAN_FLAG=0
FORMAL_FLAG=0
BUILD_TYPE_FLAG=0
EDIT_FLAG=0
NO_META_PATCH_FLAG=0

# read the options
TEMP=`getopt -o ha::bc: --long serial,std,rt,installer,no-descendants,no-meta-patch,no-build-info,help,formal,clean,edit,arga::,argb,argc: -n 'build-srpms' -- "$@"`

if [ $? -ne 0 ]; then
    usage
    exit 1
fi

eval set -- "$TEMP"

export BUILD_TYPE=std

# extract options and their arguments into variables.
while true ; do
    case "$1" in
        -a|--arga)
            case "$2" in
                "") ARG_A='some default value' ; shift 2 ;;
                *) ARG_A=$2 ; shift 2 ;;
            esac ;;
        -b|--argb) ARG_B=1 ; shift ;;
        --no-descendants) NO_DESCENDANTS=1 ; shift ;;
        --no-build-info) NO_BUILD_INFO=1 ; shift ;;
        -h|--help) HELP=1 ; shift ;;
        -c|--argc)
            case "$2" in
                "") shift 2 ;;
                *) ARG_C=$2 ; shift 2 ;;
            esac ;;
        --clean) CLEAN_FLAG=1 ; shift ;;
        --formal) FORMAL_FLAG=1 ; shift ;;
        --std) BUILD_TYPE_FLAG=1; BUILD_TYPE=std; shift ;;
        --rt) BUILD_TYPE_FLAG=1; BUILD_TYPE=rt; shift ;;
        --installer) BUILD_TYPE=installer; shift ;;
        --edit) EDIT_FLAG=1 ; shift ;;
        --no-meta-patch) NO_META_PATCH_FLAG=1 ; shift ;;
        --serial) shift ;;
        --) shift ; break ;;
        *) echo "Internal error!" ; exit 1 ;;
    esac
done

# Reset variables
if [ -n "$MY_WORKSPACE" ]; then
   export MY_WORKSPACE_TOP=${MY_WORKSPACE_TOP:-$MY_WORKSPACE}
   export MY_WORKSPACE=$MY_WORKSPACE_TOP/$BUILD_TYPE
else
   export MY_PATCH_WORKSPACE_TOP=${MY_PATCH_WORKSPACE_TOP:-$MY_PATCH_WORKSPACE}
   export MY_PATCH_WORKSPACE=$MY_PATCH_WORKSPACE_TOP/$BUILD_TYPE
fi

export MY_BUILD_DIR_TOP=${MY_BUILD_DIR_TOP:-$MY_BUILD_DIR}
export MY_BUILD_DIR=$MY_BUILD_DIR_TOP/$BUILD_TYPE

export MY_BUILD_ENVIRONMENT_TOP=${MY_BUILD_ENVIRONMENT_TOP:-$MY_BUILD_ENVIRONMENT}
export MY_BUILD_ENVIRONMENT=$MY_BUILD_ENVIRONMENT_TOP-$BUILD_TYPE

export MY_BUILD_ENVIRONMENT_FILE=$MY_BUILD_ENVIRONMENT.cfg
export MY_SRC_RPM_BUILD_DIR=$MY_BUILD_DIR/rpmbuild
export MY_BUILD_CFG=$MY_WORKSPACE/$MY_BUILD_ENVIRONMENT_FILE
export MY_MOCK_ROOT=$MY_WORKSPACE/mock/root

if [ "$BUILD_TYPE" != "std" ]; then
   PKG_DIRS_FILE=centos_pkg_dirs_$BUILD_TYPE
fi

echo "CLEAN_FLAG=$CLEAN_FLAG"
TARGETS=$@

if [ $HELP -eq 1 ]; then
    usage
    exit 0
fi

if [ $FORMAL_FLAG -eq 1 ]; then
   export FORMAL_BUILD="yes"
fi

if [ "x$TARGETS" == "x" ] && [ $EDIT_FLAG -eq 1 ]; then
    echo "ERROR: a package name is required when --edit is specified"
    usage
    exit 0
fi

SRC_ROOT="$MY_REPO"
if [ "x$MY_REPO" == "x" ]; then
   SRC_ROOT=$INITIAL_DIR
fi

BUILD_ROOT="$MY_WORKSPACE"
if [ "x$MY_WORKSPACE" == "x" ]; then
   BUILD_ROOT="$MY_PATCH_WORKSPACE"

   if [ "x$MY_PATCH_WORKSPACE" == "x" ]; then
       echo "ERROR: require one of MY_WORKSPACE or MY_PATCH_WORKSPACE be defined"
       exit 1
   fi
fi

export CCACHE_DIR="$BUILD_ROOT/.ccache"
export SRC_BASE="$SRC_ROOT"
export STX_BASE="$SRC_BASE/stx"
export CGCS_BASE="$STX_BASE"
export SPECS_BASE="$ORIG_SPECS_PATH"
export FILES_BASE="$FILES_PATH"
export PATCHES_BASE="$PATCHES_PATH"

export BUILD_BASE="$BUILD_ROOT"
BUILD_INPUTS="$BUILD_BASE/inputs"
SRPM_ASSEMBLE="$BUILD_BASE/srpm_assemble"
SRPM_WORK="$BUILD_BASE/srpm_work"

if [ "x$MY_SRC_RPM_BUILD_DIR" != "x" ]; then
    RPM_BUILD_ROOT=$MY_SRC_RPM_BUILD_DIR
else
    RPM_BUILD_ROOT=$BUILD_BASE/rpmbuild
fi

create_output_dirs

export RPM_BUILD_BASE="$RPM_BUILD_ROOT"
export SRPM_OUT="$RPM_BUILD_BASE/SRPMS"
export RPM_DIR="$RPM_BUILD_BASE/RPMS"

if [ ! -d $CGCS_BASE ]; then
   echo "ERROR: expected to find directory at '$CGCS_BASE'"
   exit 1
fi

if [ ! -d $BUILD_BASE ]; then
   echo "ERROR: expected to find directory at '$BUILD_BASE'"
   exit 1
fi

RELEASE_INFO_FILE=$STX_BASE/middleware/recipes-common/build-info/release-info.inc
if [ -f $RELEASE_INFO_FILE ]; then
   source $RELEASE_INFO_FILE
else
   echo "ERROR: failed to find RELEASE_INFO_FILE=$RELEASE_INFO_FILE"
   exit 1
fi

if [ "x$PLATFORM_RELEASE" == "x" ]; then
   echo "ERROR: PLATFORM_RELEASE is not defined in $RELEASE_INFO_FILE"
   exit 1
fi

export PLATFORM_RELEASE

mkdir -p $RPM_BUILD_BASE
if [ $? -ne 0 ]; then
   echo "ERROR: Failed to create directory '$RPM_BUILD_BASE'"
   exit 1
fi

mkdir -p $SRPM_OUT
if [ $? -ne 0 ]; then
   echo "ERROR: Failed to create directory '$SRPM_OUT'"
   exit 1
fi

mkdir -p $RPM_DIR
if [ $? -ne 0 ]; then
   echo "ERROR: Failed to create directory '$RPM_DIR'"
   exit 1
fi

build_dir () {
   local d=$1
   local w=$2
   export PKG_BASE=$d
   export WORK_BASE=$w
   export SPECS_BASE="$PKG_BASE/$ORIG_SPECS_PATH"
   local RC

   local ORIG_DIR=`pwd`
   # echo "build_dir: PKG_BASE=$PKG_BASE"

   cd "$PKG_BASE"
   if [ $? -ne 0 ]; then
      echo "ERROR: failed to cd into '$PKG_BASE'"
      return 1
   fi

   if [ ! -d $ORIG_SPECS_PATH ]; then
      # nothing to do
      echo "WARNING: '$ORIG_SPECS_PATH' not found in '$PKG_BASE'"
      cd "$ORIG_DIR"
      return 0
   fi

   SRPM_COUNT=0
   ORIG_SRPM_PATH=""
   if [ -f $SRPM_LIST_PATH ]; then
      # we've found a file (ex centos/srpm_path) which lists a path to a source
      # RPM file
      #
      # The specified file can be of the form
      #
      # repo:path/to/file.src.rpm
      # mirror:path/to/file.src.rpm
      # /path/to/file.rpm
      # path/to/file.rpm
      #
      # If "repo:" is specified, then we search for the file relative to
      # $REPO_DOWNLOADS_ROOT (i.e. a path to the file in a "downloads subgit)
      #
      # If "mirror:" is specified, then we search for the file relateive to
      # $MIRROR_ROOT 
      #
      # If "3rd_party:" is specified, then we search for the file relateive to
      # $THIRD_PARTY_ROOT 
      #
      # An absolute path is parsed as an absolute path (mainly intended for
      # developer/experimental use without checking in files or messing with
      # your git repos)
      #
      # A lack of prefix (relative path name) is interpretted as "mirror:"
      # (legacy support for existing packages)
      #
      # Other prefixes (file:, http:, whatever:)are unsupported at this time

      for p in `grep -v '^#' $SRPM_LIST_PATH | grep -v '^$'`; do
         # absolute path source rpms
         echo "$p" | grep "^/" >/dev/null && ORIG_SRPM_PATH=$p

         if [ "${ORIG_SRPM_PATH}x" == "x" ]; then
            # handle repo: definitions
            echo "$p" | grep "^repo:" >/dev/null && ORIG_SRPM_PATH=`echo $p | sed "s%^repo:%$REPO_DOWNLOADS_ROOT/%"`
         fi

         if [ "${ORIG_SRPM_PATH}x" == "x" ]; then
            # handle mirror: definitions
            echo "$p" | grep "^3rd_party:" >/dev/null && ORIG_SRPM_PATH=`echo $p | sed "s%^3rd_party:%$THIRD_PARTY_ROOT/%"`
         fi

         if [ "${ORIG_SRPM_PATH}x" == "x" ]; then
            # handle mirror: definitions
            echo "$p" | grep "^mirror:" >/dev/null && ORIG_SRPM_PATH=`echo $p | sed "s%^mirror:%$MIRROR_ROOT/%" |  sed "s#CentOS/tis-r3-CentOS/kilo/##" | sed "s#CentOS/tis-r3-CentOS/mitaka/##"`
         fi

         if [ "${ORIG_SRPM_PATH}x" == "x" ]; then
            # we haven't found a valid prefix yet, so assume it's a legacy
            # file (mirror: interpretation)
            ORIG_SRPM_PATH="$MIRROR_ROOT/$p"
         fi

         # echo "ORIG_SRPM_PATH=$ORIG_SRPM_PATH"
         if [ -f $ORIG_SRPM_PATH ]; then
             SRPM_COUNT=$((SRPM_COUNT + 1))
         else
             echo "ERROR: Invalid srpm path '$p', evaluated as '$ORIG_SRPM_PATH', found in '$SRPM_LIST_PATH'"
             ORIG_SRPM_PATH=""
             exit 1
         fi 
      done
   fi

   # Clean up an tmp_spec_*.spec file left by a prior failed build
   for f in $(find $ORIG_SPECS_PATH -name 'tmp_spec_*.spec'); do 
      \rm -f $f
   done

   SPEC_COUNT=`find $ORIG_SPECS_PATH -name '*.spec' | wc -l`
   if [ $SPEC_COUNT -eq 0 ]; then
      if [ -f $ORIG_SPECS_PATH/spec_path ]; then
         SPECS_BASE=$SRC_BASE/$(cat $SPECS_BASE/spec_path)
         SPEC_COUNT=`find $SPECS_BASE -maxdepth 1 -name '*.spec' | wc -l`
      fi
   fi

   if [ $SPEC_COUNT -eq 0 ] && [ $SRPM_COUNT -eq 0 ]; then
      # nothing to do
      echo "ERROR: Neither srpm_path nor .spec file not found in '$PKG_BASE/$ORIG_SPECS_PATH'"
      cd "$ORIG_DIR"
      return 0
   fi


   if [ $SPEC_COUNT -gt 0 ] && [ $SRPM_COUNT -gt 0 ]; then
      # nothing to do
      echo "ERROR: Please provide only one of srpm_path or .spec files, not both, in '$PKG_BASE/$ORIG_SPECS_PATH'"
      cd $ORIG_DIR
      return 0
   fi

   if [  $SPEC_COUNT -gt 0 ]; then
      build_dir_spec
      RC=$?
      cd "$ORIG_DIR"
      return $RC
   else
      build_dir_srpm $ORIG_SRPM_PATH
      RC=$?
      cd "$ORIG_DIR"
      return $RC
   fi

   cd "$ORIG_DIR"
   return 0
}


clean_srpm_dir () {
   local DIR=$1
   local SRPM_PATH
   local SRPM_FILE
   local SRPM_OUT_PATH
   local SRPM_NAME
   local SRPM_OUT_NAME
   local INPUTS_TO_CLEAN=""

   echo "clean_srpm_dir DIR=$DIR"
   for SRPM_PATH in `find "$DIR" -name '*.src.rpm'`; do
       SRPM_FILE=$(basename $SRPM_PATH)
       SRPM_NAME=$(rpm -q --queryformat '%{NAME}\n' --nosignature -p $SRPM_PATH 2>> /dev/null)
       rm -fv $SRPM_PATH $SRPM_OUT/$SRPM_FILE  
       if [ -d $SRPM_ASSEMBLE/$SRPM_NAME ]; then
           echo "rm -rf $SRPM_ASSEMBLE/$SRPM_NAME"
           rm -rf $SRPM_ASSEMBLE/$SRPM_NAME
       fi
       INPUTS_TO_CLEAN=$(if [ "x$INPUTS_TO_CLEAN" != "x" ]; then echo $INPUTS_TO_CLEAN; fi; find $BUILD_INPUTS -type d -name $SRPM_NAME)
       for SRPM_OUT_PATH in `ls -1 $SRPM_OUT/$SRPM_NAME* 2>> /dev/null`; do
           SRPM_OUT_NAME=$(rpm -q --queryformat '%{NAME}\n' -p $SRPM_OUT_PATH 2>> /dev/null)
           if [ "$SRPM_NAME" == "$SRPM_OUT_NAME" ]; then
              rm -fv $SRPM_OUT_PATH
           fi
       done
   done

   if [ "x$INPUTS_TO_CLEAN" != "x" ]; then
       for d in $INPUTS_TO_CLEAN; do
           if [ -d $d ]; then
               echo "rm -rf $d"
               rm -rf $d
           fi
       done
   fi
}

build_dir_srpm () {
   local ORIG_SRPM_PATH=$1

   local ORIG_SRPM=$(basename $ORIG_SRPM_PATH)
   local NAME=`rpm -q --queryformat '%{NAME}\n' --nosignature -p $ORIG_SRPM_PATH`
   local PKG_NAME_VER=`rpm -q --queryformat '%{NAME}-%{VERSION}-%{RELEASE}\n' --nosignature -p $ORIG_SRPM_PATH`
   local PKG_DIR="$NAME"
   local TARGET_FOUND=""
   local RC=0

   local NEED_BUILD=0

   if [ "x$TARGETS" == "x" ]; then
      NEED_BUILD=1
      TARGET_FOUND=$NAME
   else
      TARGET_LIST=( $TARGETS )
      TARGET_FOUND=$(srpm_match_target_list TARGET_LIST  "$ORIG_SRPM_PATH" 2>> /dev/null)
      if [ $? -eq 0 ]; then
         echo "found target '$TARGET_FOUND' in '$ORIG_SRPM'"
         NEED_BUILD=1
         UNRESOLVED_TARGETS=$(echo "$UNRESOLVED_TARGETS" | sed "s/\(^\|[[:space:]]\)$TARGET_FOUND\([[:space:]]\|$\)/ /g")
      fi
   fi

   if [ $NEED_BUILD -eq 0 ]; then
      return 0
   fi

   local ROOT_DIR="$SRPM_ASSEMBLE"   
   if [ $EDIT_FLAG -eq 1 ]; then
      mkdir -p $SRPM_WORK
      ROOT_DIR="$SRPM_WORK"
   fi
   local PKG_ROOT_DIR="$ROOT_DIR/$PKG_DIR"   
   local BUILD_DIR="$PKG_DIR/rpmbuild"
   local FULL_BUILD_DIR="$ROOT_DIR/$BUILD_DIR"
   local SRPM_DIR="$FULL_BUILD_DIR/SRPMS"
   
   if [ $CLEAN_FLAG -eq 1 ]; then
      # clean
      echo "===== Cleaning '$TARGET_FOUND' ====="

      if [ -d $SRPM_DIR ] && [ $EDIT_FLAG -eq 0 ]; then
         clean_srpm_dir "$SRPM_DIR"
      fi

      if [ -d $PKG_ROOT_DIR ]; then
          echo "rm -rf $PKG_ROOT_DIR"
          rm -rf "$PKG_ROOT_DIR"
      fi
   else
      #build
      echo "===== Build SRPM for '$TARGET_FOUND' ====="
      echo "PKG_BASE=$PKG_BASE"
      echo "BUILD_DIR=$BUILD_DIR"
      echo "SRPM_DIR=$SRPM_DIR"

      if [ ! -d $ROOT_DIR ]; then
         mkdir -p "$ROOT_DIR"
         if [ $? -ne 0 ]; then
            echo "ERROR: build_dir_srpm: mkdir '$ROOT_DIR' failed"
            return 1
         fi
      fi

      export DATA="$DATA_PATH/$SRPM_DATA"
      local COPY_LIST
      local COPY_LIST_TO_TAR
      local SRC_DIR
      local TIS_PATCH_VER

      srpm_source_build_data $DATA
      if [ $? -ne 0 ]; then
          echo "ERROR: build_dir_srpm: failed to source $DATA"
          return 1
      fi

      local BUILD_NEEDED=2
      local SRPM_OUT_PATH2

      for SRPM_PATH in `find "$FULL_BUILD_DIR/SRPMS" -name '*.src.rpm' | sort -V`; do
         if [ $BUILD_NEEDED -eq 2 ]; then
            BUILD_NEEDED=0
         fi

         b=$(basename $SRPM_PATH)
         SRPM_OUT_PATH2=`find $SRPM_OUT -name $b`
         if [ "x$SRPM_OUT_PATH2" == "x" ]; then
            BUILD_NEEDED=1
         fi
         
         n=`find $PKG_BASE -type f -cnewer $SRPM_PATH | wc -l`
         if [ $n -gt 0 ]; then
            BUILD_NEEDED=1
         fi

         n=`find $ORIG_SRPM_PATH -type f -cnewer $SRPM_PATH | wc -l`
         if [ $n -gt 0 ]; then
            BUILD_NEEDED=1
         fi

         if [ -f $PKG_BASE/$DATA ]; then
            (
            cd $PKG_BASE
            BUILD_NEEDED=0
            srpm_source_build_data $DATA

            # NOTE: SRC_DIR is not honored in this build path

            if [ "x$COPY_LIST" != "x" ]; then
               n=`find $COPY_LIST -type f -cnewer $SRPM_PATH | wc -l`
               if [ $n -gt 0 ]; then
                  BUILD_NEEDED=1
               fi
            fi

            # NOTE: COPY_LIST_TO_TAR is not honored in this build path

            exit $BUILD_NEEDED
            )
            if [ $? -gt 0 ]; then
               BUILD_NEEDED=1
            fi
         fi
      done
   
      if [ $BUILD_NEEDED -eq 0 ]; then
         echo "SRPM build not required for '$PKG_BASE'"
         echo "===== Build complete for '$TARGET_FOUND' ====="
         echo
         return 0
      fi
   
      if [ $EDIT_FLAG -eq 0 ]; then
         clean_srpm_dir "$FULL_BUILD_DIR/SRPMS"

         if [ -d $PKG_ROOT_DIR ]; then
            echo "arf rm -rf $PKG_ROOT_DIR"
            rm -rf $PKG_ROOT_DIR
         fi
      fi

      if [ $EDIT_FLAG -eq 1 ]; then
         PKG_CLASSIFICATION=$(classify $PKG_BASE)
         echo "$PKG_CLASSIFICATION = classify $PKG_BASE"
         if [ "$PKG_CLASSIFICATION" == "spec + tarball" ] || [ "$PKG_CLASSIFICATION" == "srpm + patches" ]; then
            echo "OK to edit $PKG_BASE"
         else
            echo "Can't edit this package, it is of type '$PKG_CLASSIFICATION', it is not derived from SRPM or tarball and patches"
            return 1
         fi

         echo "srpm_extract_to_git '$ORIG_SRPM_PATH' '$PKG_BASE' '$ROOT_DIR' '$BUILD_DIR' '$PKG_NAME_VER' '$NO_META_PATCH_FLAG' '$TIS_PATCH_VER'"
         srpm_extract_to_git $ORIG_SRPM_PATH $PKG_BASE $ROOT_DIR $BUILD_DIR $PKG_NAME_VER $NO_META_PATCH_FLAG $TIS_PATCH_VER
         RC=$?
         if [ $RC -ne 0 ]; then
            if [ $RC -eq 1 ]; then
               echo "ERROR: srpm_extract_to_git: failed to extract srpm '$ORIG_SRPM_PATH'"
            fi
            return $RC
         fi

         local LOC=$(for g in $(find $PKG_ROOT_DIR/gits -type d -name .git); do d=$(dirname $g); (cd $d;  git tag | grep "pre_wrs_$PKG_NAME_VER" >> /dev/null; if [ $? -eq 0 ]; then echo $d; fi); done | head -n 1 )
         echo "===== '$TARGET_FOUND' has been extracted for editing. ====="
         echo "===== Metadata can be found at: $PKG_ROOT_DIR/rpmbuild"
         echo "===== Source code can be found at: $LOC"
         return 0
      fi

      AGE=`find $PKG_BASE $ORIG_SRPM_PATH -type f -exec stat --format '%Y' "{}" \; | grep -v '[/][.]git$' | grep -v '[/][.]git[/]' | sort -nr | head -n 1`
      if [ -f $PKG_BASE/$DATA ]; then
         AGE2=$(
               cd $PKG_BASE
               srpm_source_build_data $DATA
               PATH_LIST=""

               # NOTE: SRC_DIR is not honored in this build path
      
               if [ "x$COPY_LIST" != "x" ]; then
                  PATH_LIST="$PATH_LIST $COPY_LIST"
               fi
      
               # NOTE: COPY_LIST_TO_TAR is not honored in this build path

      
               if [ "x$PATH_LIST" == "x" ]; then
                  echo "0"
               else
                  AGE2=`find $PATH_LIST -type f -exec stat --format '%Y' "{}" \; | grep -v '[/][.]git$' | grep -v '[/][.]git[/]' | sort -nr | head -n 1`
                  echo  "$AGE2"
               fi
               )
          if [ $AGE2 -gt $AGE ]; then
             AGE=$AGE2
          fi
      fi
      
      srpm_extract $ORIG_SRPM_PATH $PKG_BASE $ROOT_DIR $BUILD_DIR $PKG_NAME_VER
      if [ $? -ne 0 ]; then
         echo "ERROR: build_dir_srpm: failed to extract srpm '$ORIG_SRPM_PATH'"
         return 1
      fi

      if [ "x$COPY_LIST" != "x" ]; then
         echo "COPY_LIST: $COPY_LIST"
         for p in $COPY_LIST; do
            # echo "COPY_LIST: $p"
            \cp -L -r -f -v $p $FULL_BUILD_DIR/SOURCES
            if [ $? -ne 0 ]; then
               echo "ERROR: COPY_LIST: file not found: '$p'"
               exit 1
            fi
         done
      fi

      srpm_assemble $FULL_BUILD_DIR $TIS_PATCH_VER
      if [ $? -ne 0 ]; then
         echo "ERROR: build_dir_srpm: failed to assemble srpm for '$PKG_NAME_VER'"
         SRPM_FAILED_REBUILD_LIST="$SRPM_FAILED_REBUILD_LIST $TARGET_FOUND"
         return 1
      fi

      TS=$(date -d @$AGE +%Y-%m-%dT%H:%M:%S)
      for s in `find $FULL_BUILD_DIR/SRPMS -name '*.src.rpm'`; do
         \cp -L -f -v $s $SRPM_OUT/
         ss=$(basename $s)
         touch $SRPM_OUT/$ss --date=$TS
      done

      SRPM_REBUILT_LIST="$SRPM_REBUILT_LIST $TARGET_FOUND"
      echo "SRPM build successful for '$PKG_NAME_VER'"
      echo "===== Build complete for '$TARGET_FOUND' ====="
      echo
   fi

   return 0
}


build_dir_spec () {
   local NEED_BUILD=0
   local TARGET_FOUND=""

   if [ "x$TARGETS" == "x" ]; then
      NEED_BUILD=1
      for f in `find $SPECS_BASE -maxdepth 1 -name '*.spec'`; do
         TARGET_FOUND=`spec_find_global service "$f" 2>> /dev/null`
         if [ $? -ne 0 ]; then
             TARGET_FOUND=`spec_find_tag Name "$f" 2>> /dev/null`
             if [ $? -ne 0 ]; then
                 TARGET_FOUND=""
             fi
         fi
      done
   else
      TARGET_LIST=( $TARGETS )
      for f in `find $SPECS_BASE -maxdepth 1 -name '*.spec' 2>> /dev/null`; do
         TARGET_FOUND=$(spec_match_target_list TARGET_LIST "$f" 2>> /dev/null)
         if [ $? -eq 0 ]; then
            echo "found target '$TARGET_FOUND' in '$f'"
            NEED_BUILD=1
            UNRESOLVED_TARGETS=$(echo "$UNRESOLVED_TARGETS" | sed "s/\(^\|[[:space:]]\)$TARGET_FOUND\([[:space:]]\|$\)/ /g")
            break
         fi
      done
   fi

   if [ $NEED_BUILD -eq 1 ]; then
      MAKE_SRPM="$SCRIPT_PATH/$SRPM_SCRIPT"
      export DATA="$DATA_PATH/$SRPM_DATA"

      export RPMBUILD_BASE="$WORK_BASE/rpmbuild"
      SRPM_PATH="$RPMBUILD_BASE/SRPMS"
      SPEC_PATH="$RPMBUILD_BASE/SPECS"
      SOURCES_PATH="$RPMBUILD_BASE/SOURCES"
      local ROOT_DIR="$RPMBUILD_BASE"
      local PKG_ROOT_DIR="$RPMBUILD_BASE"
      local SPEC=$(find $SPECS_BASE -maxdepth 1 -name '*.spec' | head -n 1)
      local NAME=$(spec_find_tag Name $SPEC)
      local PKG_NAME_VER=$(spec_name_ver_rel $SPEC)
      local PKG_DIR="$NAME"
      local BUILD_DIR="$PKG_DIR/rpmbuild"
      local FULL_BUILD_DIR="$ROOT_DIR/$BUILD_DIR"
      local SRPM_DIR="$FULL_BUILD_DIR/SRPMS"

      if [ $EDIT_FLAG -eq 1 ]; then
         mkdir -p $SRPM_WORK
         ROOT_DIR="$SRPM_WORK"
         PKG_ROOT_DIR="$ROOT_DIR/$PKG_DIR"   
      fi

      if [ $CLEAN_FLAG -eq 1 ]; then
         # clean
         echo "===== Cleaning '$TARGET_FOUND' ====="
         if [ -d $SRPM_PATH ] && [ $EDIT_FLAG -eq 0 ]; then
            clean_srpm_dir $SRPM_PATH
         fi

         if [ -d $PKG_ROOT_DIR ]; then
             echo "rm -rf $PKG_ROOT_DIR"
             rm -rf "$PKG_ROOT_DIR"
         fi
      else
         # build
         echo "===== Build SRPM for '$TARGET_FOUND' ====="
         echo "PKG_BASE=$PKG_BASE"
         echo "WORK_BASE=$WORK_BASE"
         echo "RPMBUILD_BASE=$RPMBUILD_BASE"
         if [ ! -x $MAKE_SRPM ]; then
            if [ ! -f $DATA ]; then
                echo "expected to find an executable script at '$MAKE_SRPM' or data for the default script at '$DATA'"
                cd $INITIAL_DIR
                exit 1
            else
                MAKE_SRPM="$DEFAULT_SRPM_SCRIPT"
            fi
         fi
   
         local BUILD_NEEDED=2
         local SRPM_OUT_PATH2

         for SRPM_PATH2 in `find "$RPMBUILD_BASE/SRPMS" -name '*.src.rpm' | sort -V`; do
            if [ $BUILD_NEEDED -eq 2 ]; then
               BUILD_NEEDED=0
            fi

            b=$(basename $SRPM_PATH2)
            SRPM_OUT_PATH2=`find $SRPM_OUT -name $b`
            if [ "x$SRPM_OUT_PATH2" == "x" ]; then
               BUILD_NEEDED=1
            fi

            n=`find $PKG_BASE -type f -cnewer $SRPM_PATH2 | wc -l`
            if [ $n -gt 0 ]; then
               BUILD_NEEDED=1
            fi

            if [ -f $PKG_BASE/$DATA ]; then
               (
               cd $PKG_BASE
               BUILD_NEEDED=0
               srpm_source_build_data $DATA
               if [ "x$SRC_DIR" != "x" ]; then
                  if [ -d "$SRC_DIR" ]; then
                     n=`find $SRC_DIR -type f -cnewer $SRPM_PATH2 | grep -v '[/][.]git$' | grep -v '[/][.]git[/]' | wc -l`
                     if [ $n -gt 0 ]; then
                        BUILD_NEEDED=1
                     fi
                  fi
               fi

               if [ "x$COPY_LIST" != "x" ]; then
                  n=`find $COPY_LIST -type f -cnewer $SRPM_PATH2 | wc -l`
                  if [ $n -gt 0 ]; then
                     BUILD_NEEDED=1
                  fi
               fi

               if [ "x$COPY_LIST_TO_TAR" != "x" ]; then
                  n=`find $COPY_LIST_TO_TAR -type f -cnewer $SRPM_PATH2 | wc -l`
                  if [ $n -gt 0 ]; then
                     BUILD_NEEDED=1
                  fi
               fi

               exit $BUILD_NEEDED
               )
               if [ $? -gt 0 ]; then
                  BUILD_NEEDED=1
               fi
            fi
         done
   
         if [ $EDIT_FLAG -eq 1 ]; then
            local COPY_LIST
            local COPY_LIST_TO_TAR
            local SRC_DIR
            local TIS_PATCH_VER

            PKG_CLASSIFICATION=$(classify $PKG_BASE)
            echo "$PKG_CLASSIFICATION = classify $PKG_BASE"
            if [ "$PKG_CLASSIFICATION" == "spec + tarball" ] || [ "$PKG_CLASSIFICATION" == "srpm + patches" ]; then
               echo "OK to edit $PKG_BASE"
            else
               echo "Can't edit this package, it is of type '$PKG_CLASSIFICATION', it is not derived from SRPM or tarball and patches"
               return 1
            fi

            srpm_source_build_data $DATA
            if [ $? -ne 0 ]; then
                echo "ERROR: build_dir_srpm: failed to source $DATA"
                return 1
            fi

            echo "tar_and_spec_extract_to_git '$SPEC' '$PKG_BASE' '$ROOT_DIR' '$BUILD_DIR' '$PKG_NAME_VER' '$NO_META_PATCH_FLAG' '$TIS_PATCH_VER'"
            tar_and_spec_extract_to_git "$SPEC" "$PKG_BASE" "$ROOT_DIR" "$BUILD_DIR" "$PKG_NAME_VER" "$NO_META_PATCH_FLAG" "$TIS_PATCH_VER"
            RC=$?
            if [ $RC -ne 0 ]; then
               if [ $RC -eq 1 ]; then
                  echo "ERROR: srpm_extract_to_git: failed to extract srpm '$ORIG_SRPM_PATH'"
               fi
               return $RC
            fi
   
            local LOC=$(for g in $(find $PKG_ROOT_DIR/gits -type d -name .git); do d=$(dirname $g); (cd $d;  git branch --all | grep "$PKG_NAME_VER" >> /dev/null; if [ $? -eq 0 ]; then echo $d; fi); done | head -n 1 )
            echo "===== '$TARGET_FOUND' has been extracted for editing. ====="
            echo "===== Metadata can be found at: $PKG_ROOT_DIR/rpmbuild"
            echo "===== Source code can be found at: $LOC"
            return 0
         fi

         if [ $BUILD_NEEDED -eq 0 ]; then
            echo "SRPM build not required for '$PKG_BASE'"
            echo "===== Build complete for '$TARGET_FOUND' ====="
            echo
            return 0
         fi


         echo "MAKE_SRPM=$MAKE_SRPM"
         echo "DATA=$DATA"
   
         if [ -d "$RPMBUILD_BASE/SRPMS" ]; then
             clean_srpm_dir "$RPMBUILD_BASE/SRPMS"
         fi
         if [ -d $RPMBUILD_BASE ]; then
             echo "rm -rf $RPMBUILD_BASE"
             rm -rf "$RPMBUILD_BASE"
         fi

         mkdir -p "$WORK_BASE" && \
         mkdir -p "$SRPM_PATH" && \
         mkdir -p "$SPEC_PATH" && \
         mkdir -p "$SOURCES_PATH" 
         if [ $? -ne 0 ]; then
             echo "ERROR: Failed to create directories under: $WORK_BASE"
         fi

         \cp -L -f -v $SPECS_BASE/*.spec $SPEC_PATH/
         if [ $? -ne 0 ]; then
             echo "ERROR: Failed to copy spec files from '$SPECS_BASE' to '$SPEC_PATH'"
         fi

         # build
         $MAKE_SRPM
         if [ $? -ne 0 ]; then
            echo "ERROR: script failed '$MAKE_SRPM'"
            SRPM_FAILED_REBUILD_LIST="$SRPM_FAILED_REBUILD_LIST $TARGET_FOUND"
            exit 1
         fi


         AGE=`find $PKG_BASE -type f -exec stat --format '%Y' "{}" \; | grep -v '[/][.]git$' | grep -v '[/][.]git[/]' | sort -nr | head -n 1`
         if [ -f $PKG_BASE/$DATA ]; then
            AGE2=$(
                  cd $PKG_BASE
                  srpm_source_build_data $DATA
                  PATH_LIST=""
                  if [ "x$SRC_DIR" != "x" ]; then
                     if [ -d "$SRC_DIR" ]; then
                        PATH_LIST="$PATH_LIST $SRC_DIR"
                     fi
                  fi

                  if [ "x$COPY_LIST" != "x" ]; then
                     PATH_LIST="$PATH_LIST $COPY_LIST"
                  fi

                  if [ "x$COPY_LIST_TO_TAR" != "x" ]; then
                     PATH_LIST="$PATH_LIST $COPY_LIST_TO_TAR"
                  fi

                  if [ "x$PATH_LIST" == "x" ]; then
                     echo "0"
                  else
                     AGE2=`find $PATH_LIST -type f -exec stat --format '%Y' "{}" \; | grep -v '[/][.]git$' | grep -v '[/][.]git[/]' | sort -nr | head -n 1`
                     echo  "$AGE2"
                  fi
                  )
             if [ $AGE2 -gt $AGE ]; then
                AGE=$AGE2
             fi
         fi

         TS=$(date -d @$AGE +%Y-%m-%dT%H:%M:%S)
         for s in `find $SRPM_PATH -name '*.src.rpm'`; do
             \cp -L -f $s $SRPM_OUT/
             ss=$(basename $s)
             touch $SRPM_OUT/$ss --date=$TS
         done

         SRPM_REBUILT_LIST="$SRPM_REBUILT_LIST $TARGET_FOUND"
         echo "===== Build complete for '$TARGET_FOUND' ====="
         echo
      fi
   fi

   return 0
}

(
echo "$CMDLINE"

if [ -L $BUILD_ROOT/repo ]; then
    REPO_DEST=`readlink $BUILD_ROOT/repo`
    if [ "$REPO_DEST" != "$SRC_ROOT" ]; then
        echo "Error: MY_REPO changed since last build"
        echo "   old path: $REPO_DEST"
        echo "   new path: $SRC_ROOT"
        echo "Please run 'build-srpms --clean' if you want to compile from a new source tree"
        exit 1
    fi
fi

if [ ! -L $BUILD_ROOT/repo ]; then
    ln -s $SRC_ROOT $BUILD_ROOT/repo
fi

ALL=0
UNRESOLVED_TARGETS=" "
if [ "x$TARGETS" == "x" ]; then
    echo "make: all"
    ALL=1
else
    echo "make: $TARGETS"
    UNRESOLVED_TARGETS="$TARGETS"
fi

if [ $EDIT_FLAG -eq 0 ]; then
    if [ $CLEAN_FLAG -eq 1 ]; then
        EXTRA_RPM_FLAGS=""

        if [ $NO_BUILD_INFO -eq 1 ]; then
           EXTRA_RPM_FLAGS+=" --no-build-info"
        fi

        if [ $BUILD_TYPE_FLAG -eq 1 ]; then
           EXTRA_RPM_FLAGS+=" --$BUILD_TYPE"
        fi

        if [ $ALL -eq 1 ]; then
           build-rpms-serial --clean  $EXTRA_RPM_FLAGS
           rm -f $BUILD_ROOT/repo
        else
           build-rpms-serial --clean $EXTRA_RPM_FLAGS $TARGETS
        fi
    fi
fi

for g in `find "$SRC_BASE" -type d -name .git | sort -V`; do
   GIT_ROOT=$(dirname $g)
   export GIT_BASE="$GIT_ROOT"
   for p in $(cat $GIT_ROOT/$PKG_DIRS_FILE 2>> /dev/null); do
      src_dir="$GIT_ROOT/$p"
      if [ -d $src_dir ]; then
         if [ -d $src_dir/centos ]; then
            rel_dir=$(echo $src_dir | sed "s:^$SRC_BASE::")
            work_dir="$BUILD_INPUTS$rel_dir"
            build_dir $src_dir $work_dir
            RC=$?
            if [ $RC -ne 0 ]; then
               if [ $RC -eq 1 ]; then
                  VERB="build"
                  if [ $EDIT_FLAG ]; then
                     VERB="edit"
                  fi
                  if [ $CLEAN_FLAG ]; then
                     VERB="clean"
                  fi
                  echo "ERROR: Failed to $VERB src.rpm from source at '$p'"
               fi
               exit 1
            fi
         else
            echo "ERROR: Failed to find 'centos' in '$p', found in file '$GIT_ROOT/$PKG_DIRS_FILE'"
         fi
      else
         echo "ERROR: Bad path '$p' in file '$GIT_ROOT/$PKG_DIRS_FILE'"
      fi
   done
done

# Try to find and clean orphaned and discontinued .src.rpm's 
if [ $ALL -eq 1 ]; then
    echo
    echo "Auditing for obsolete srpms"
    PACKAGES_CONSIDERED=""
    for g in `find $SRC_BASE -type d -name .git | sort -V`; do
        GIT_ROOT=$(dirname $g)
        for p in $(cat $GIT_ROOT/$PKG_DIRS_FILE 2>> /dev/null); do
            src_dir="$GIT_ROOT/$p"
            if [ -d $src_dir ]; then
                if [ -d $src_dir/$DISTRO ]; then

                    for f in `find $src_dir/centos -name '*.spec' | sort -V`; do
                        NAME=`spec_find_tag Name "$f" 2>> /dev/null`
                        if [ $? -eq 0 ]; then
                            PACKAGES_CONSIDERED="$PACKAGES_CONSIDERED $NAME"
                        fi
                    done
                    if [ -f $src_dir/$SRPM_LIST_PATH ]; then

                        for p in `grep -v '^#' $src_dir/$SRPM_LIST_PATH | grep -v '^$'`; do
                           ORIG_SRPM_PATH=""
                           # absolute path source rpms
                           echo "$p" | grep "^/" >/dev/null && ORIG_SRPM_PATH=$p

                           if [ "${ORIG_SRPM_PATH}x" == "x" ]; then
                              # handle repo: definitions
                              echo "$p" | grep "^repo:" >/dev/null && ORIG_SRPM_PATH=`echo $p | sed "s%^repo:%$REPO_DOWNLOADS_ROOT/%"`
                           fi

                           if [ "${ORIG_SRPM_PATH}x" == "x" ]; then
                              # handle repo: definitions
                              echo "$p" | grep "^3rd_party:" >/dev/null && ORIG_SRPM_PATH=`echo $p | sed "s%^3rd_party:%$THIRD_PARTY_ROOT/%"`
                           fi

                           if [ "${ORIG_SRPM_PATH}x" == "x" ]; then
                              # handle mirror: definitions
                              echo "$p" | grep "^mirror:" >/dev/null && ORIG_SRPM_PATH=`echo $p | sed "s%^mirror:%$MIRROR_ROOT/%" | sed "s#CentOS/tis-r3-CentOS/kilo/##" | sed "s#CentOS/tis-r3-CentOS/mitaka/##"`
                           fi

                           if [ "${ORIG_SRPM_PATH}x" == "x" ]; then
                              # we haven't found a valid prefix yet, so assume it's a legacy
                              # file (mirror: interpretation)
                              ORIG_SRPM_PATH="$MIRROR_ROOT/$p"
                           fi

                           if [ -f $ORIG_SRPM_PATH ]; then
                               NAME=`rpm -q --queryformat '%{NAME}\n' -p $ORIG_SRPM_PATH 2>> /dev/null`
                               if [ $? -eq 0 ]; then
                                   PACKAGES_CONSIDERED="$PACKAGES_CONSIDERED $NAME"
                               fi
                           fi
                        done
                    fi
                fi
            fi
        done
    done

    for r in $(find $SRPM_OUT -name '*.src.rpm' | sort -V); do
        NAME=$(rpm -q --queryformat '%{NAME}\n' -p $r 2>> /dev/null)
        FOUND=0
        for p in $PACKAGES_CONSIDERED; do
            if [[ "$NAME" == "$p" || ( "$BUILD_TYPE" != "std" && "$NAME" == "$p-$BUILD_TYPE" ) ]]; then
                FOUND=1
                break
            fi
        done
        if [ $FOUND -eq 0 ]; then
            for INPUT_DIR in $(find $BUILD_INPUTS -name $NAME | sort -V); do
                if [ -d "$INPUT_DIR/rpmbuild/SRPMS" ]; then
                    clean_srpm_dir "$INPUT_DIR/rpmbuild/SRPMS"
                fi
                if [ -d $INPUT_DIR ]; then
                    echo "rm -rf $r"
                    rm -rf $r
                fi
            done
            if [ -f $r ]; then
                rm -f -v $r
            fi
        fi
    done
set +x
fi

if [ $CLEAN_FLAG -eq 1 ]; then
    if [ $ALL -eq 1 ]; then
       rm -rf $BUILD_INPUTS 
    fi
fi

if [ $EDIT_FLAG -ne 1 ]; then
   echo "==== Update repodata ====="
   mkdir -p $SRPM_OUT/repodata
   for d in `find -L $SRPM_OUT -type d -name repodata`; do
      (cd $d/..
       rm -rf repodata
       $CREATEREPO `pwd`
      )
   done
   echo "==== Update repodata complete ====="
fi

if [ $CLEAN_FLAG -eq 0 ] && [ $EDIT_FLAG -eq 0 ]; then
    echo ""
    if [ "$SRPM_FAILED_REBUILD_LIST" != "" ]; then
       N=`echo "$SRPM_FAILED_REBUILD_LIST" | wc -w`
       echo "Failed to build $N packages:"
       echo "   $SRPM_FAILED_REBUILD_LIST"
    fi
    if [ "$SRPM_REBUILT_LIST" != "" ]; then
       N=`echo "$SRPM_REBUILT_LIST" | wc -w`
       echo "Successfully built $N packages:"
       echo "   $SRPM_REBUILT_LIST"
       echo ""
       echo "Compiled src.rpm's can be found here: $SRPM_OUT"
    fi
    if [ "$SRPM_FAILED_REBUILD_LIST" == "" ] && [ "$SRPM_REBUILT_LIST" == "" ]; then
       echo "No packages required a rebuild"
    fi
fi


if [ "$UNRESOLVED_TARGETS" != " " ]; then
    echo ""
    echo "ERROR: failed to resolve build targets: $UNRESOLVED_TARGETS"
    exit 1
fi

exit 0
) 2>&1 | stdbuf -o0 awk '{ print strftime("%H:%M:%S"), $0; fflush(); }' | tee $(date "+$MY_WORKSPACE/build-srpms-serial_%Y-%m-%d_%H-%M-%S.log") ; exit ${PIPESTATUS[0]}
