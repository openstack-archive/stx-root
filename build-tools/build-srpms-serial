#!/bin/bash
# set -x

#
# Copyright (c) 2018 Wind River Systems, Inc.
#
# SPDX-License-Identifier: Apache-2.0
#

#
# Create src.rpm files from source, or from a downloaded tarball
# or src.rpm plus our additional patches.
#
# This version only tries to compile on package at a time.
#
# The location of packages to be build are identified by
# <distro>_pkg_dirs[_<opt-build-type>] files located at the root of
# any git tree (e.g. stx/stx-integ/centos_pkg_dirs).
#
# The build of an individul package is driven by it's build_srpm.data
# file plus a <pkg-name>.spec file or an srpm_path file.
#

export ME=$(basename "$0")
CMDLINE="$ME $@"


BUILD_SRPMS_SERIAL_DIR="$(dirname "$(readlink -f "${BASH_SOURCE[0]}" )" )"
source $BUILD_SRPMS_SERIAL_DIR/git-utils.sh
source $BUILD_SRPMS_SERIAL_DIR/spec-utils
source $BUILD_SRPMS_SERIAL_DIR/srpm-utils
source $BUILD_SRPMS_SERIAL_DIR/classify
source $BUILD_SRPMS_PARALLEL_DIR/build-srpms-common.sh


INITIAL_DIR=$(pwd)
export DISTRO="centos"
SRPM_SCRIPT="build_srpm"
SRPM_DATA="build_srpm.data"
PKG_DIRS_FILE="${DISTRO}_pkg_dirs"

DEFAULT_SRPM_SCRIPT="$BUILD_SRPMS_SERIAL_DIR/default_$SRPM_SCRIPT"
SCRIPT_PATH="$DISTRO"
DATA_PATH="$DISTRO"
FILES_PATH="$DISTRO/files"
PATCHES_PATH="$DISTRO/patches"
ORIG_SPECS_PATH="$DISTRO"
SRPM_LIST_PATH="$DISTRO/srpm_path"
MIRROR_ROOT="$MY_REPO/cgcs-${DISTRO}-repo"
THIRD_PARTY_ROOT="$MY_REPO/cgcs-3rd-party-repo"
REPO_DOWNLOADS_ROOT="$MY_REPO"
SRPM_REBUILT_LIST=""
SRPM_FAILED_REBUILD_LIST=""

CREATEREPO=$(which createrepo_c)
if [ $? -ne 0 ]; then
   CREATEREPO="createrepo"
fi

usage () {
    echo ""
    echo "Usage: "
    echo "   Create source rpms:"
    echo "      $ME [--rt | --std | --installer] [--no-descendants] [--formal] [ list of package names ]"
    echo ""
    echo "   Delete source rpms, and the directories associated with it's creation:"
    echo "   Note: does not clean an edit environment"
    echo "      $ME --clean [--rt | --std | --installer] [optional list of package names]"
    echo ""
    echo "   Extract an src.rpm into a pair of git trees to aid in editing it's contents,"
    echo "   one for source code and one for metadata such as the spec file."
    echo "   If --no-meta-patch is specified, then WRS patches are omitted."
    echo "      $ME --edit [--rt | --std | --installer] [--no-meta-patch] [list of package names]"
    echo ""
    echo "   Delete an edit environment"
    echo "      $ME --edit --clean [--rt | --std | --installer] [list of package names]"
    echo ""
    echo "   This help page"
    echo "      $ME --help"
    echo ""
}


spec_cache_dir_from_srpm () {
   local SRPM=${1}
   local SPEC_DIR=$(echo $SRPM | sed 's#/SRPMS/#/SPECS/#')
   echo "$SPEC_DIR"
}

result_dir_from_srpm () {
   local SRPM=$(basename ${1} | sed 's#.src.rpm$##')
   local RESULT_DIR="$MY_WORKSPACE/results/$MY_BUILD_ENVIRONMENT/$SRPM"
   echo "$RESULT_DIR"
}

# This function creates a bunch of subdirs in $MY_WORKSPACE and makes sure
# that a $MY_BUILD_CFG file exists.
#
# The goal of this is to have a script do as much of the annoying
# grunt-work so that the "how to build it" instructions aren't 200 lines
create_output_dirs () {
	# make sure variables are sane before continuing
	# Note that $BUILD_ROOT contains either $MY_WORKSPACE or $MY_PATCH_WORKSPACE
	if [ "x$BUILD_ROOT" == "x" ]; then
		return
	fi
	if [ "x$MY_BUILD_CFG" == "x" ]; then
		return
	fi
	if [ "x$MY_BUILD_DIR" == "x" ]; then
		return
	fi
	if [ "x$MY_SRC_RPM_BUILD_DIR" == "x" ]; then
		return
	fi

	# create output dirs
	mkdir -p $MY_BUILD_DIR
	mkdir -p $MY_SRC_RPM_BUILD_DIR
	mkdir -p $MY_SRC_RPM_BUILD_DIR/SOURCES
	mkdir -p $MY_SRC_RPM_BUILD_DIR/SPECS
	mkdir -p $MY_SRC_RPM_BUILD_DIR/BUILD
	mkdir -p $MY_SRC_RPM_BUILD_DIR/RPMS
	mkdir -p $MY_SRC_RPM_BUILD_DIR/SRPMS

	# create $MY_BUILD_CFG, if required
	if [ ! -f $MY_BUILD_CFG ]; then
           echo "FORMAL_BUILD=$FORMAL_BUILD"
           echo "modify-build-cfg $MY_BUILD_CFG"
           ${DIR}/modify-build-cfg $MY_BUILD_CFG
           if [ $? -ne 0 ]; then
               echo "Could not modifiy $MY_BUILD_CFG";
               exit 1
           fi
	fi

}

NO_DESCENDANTS=0
NO_BUILD_INFO=0
HELP=0
CLEAN_FLAG=0
FORMAL_FLAG=0
BUILD_TYPE_FLAG=0
EDIT_FLAG=0
NO_META_PATCH_FLAG=0

# read the options
TEMP=$(getopt -o ha::bc: --long serial,std,rt,installer,no-descendants,no-meta-patch,no-build-info,help,formal,clean,edit,arga::,argb,argc: -n "$ME" -- "$@")

if [ $? -ne 0 ]; then
    usage
    exit 1
fi

eval set -- "$TEMP"

export BUILD_TYPE=std

# extract options and their arguments into variables.
while true ; do
    case "$1" in
        -a|--arga)
            case "$2" in
                "") ARG_A='some default value' ; shift 2 ;;
                *) ARG_A=$2 ; shift 2 ;;
            esac ;;
        -b|--argb) ARG_B=1 ; shift ;;
        --no-descendants) NO_DESCENDANTS=1 ; shift ;;
        --no-build-info) NO_BUILD_INFO=1 ; shift ;;
        -h|--help) HELP=1 ; shift ;;
        -c|--argc)
            case "$2" in
                "") shift 2 ;;
                *) ARG_C=$2 ; shift 2 ;;
            esac ;;
        --clean) CLEAN_FLAG=1 ; shift ;;
        --formal) FORMAL_FLAG=1 ; shift ;;
        --std) BUILD_TYPE_FLAG=1; BUILD_TYPE=std; shift ;;
        --rt) BUILD_TYPE_FLAG=1; BUILD_TYPE=rt; shift ;;
        --installer) BUILD_TYPE=installer; shift ;;
        --edit) EDIT_FLAG=1 ; shift ;;
        --no-meta-patch) NO_META_PATCH_FLAG=1 ; shift ;;
        --serial) shift ;;
        --) shift ; break ;;
        *) echo "Internal error!" ; exit 1 ;;
    esac
done

# Reset variables
if [ -n "$MY_WORKSPACE" ]; then
   export MY_WORKSPACE_TOP=${MY_WORKSPACE_TOP:-$MY_WORKSPACE}
   export MY_WORKSPACE=$MY_WORKSPACE_TOP/$BUILD_TYPE
else
   export MY_PATCH_WORKSPACE_TOP=${MY_PATCH_WORKSPACE_TOP:-$MY_PATCH_WORKSPACE}
   export MY_PATCH_WORKSPACE=$MY_PATCH_WORKSPACE_TOP/$BUILD_TYPE
fi

export MY_BUILD_DIR_TOP=${MY_BUILD_DIR_TOP:-$MY_BUILD_DIR}
export MY_BUILD_DIR=$MY_BUILD_DIR_TOP/$BUILD_TYPE

export MY_BUILD_ENVIRONMENT_TOP=${MY_BUILD_ENVIRONMENT_TOP:-$MY_BUILD_ENVIRONMENT}
export MY_BUILD_ENVIRONMENT=$MY_BUILD_ENVIRONMENT_TOP-$BUILD_TYPE

export MY_BUILD_ENVIRONMENT_FILE=$MY_BUILD_ENVIRONMENT.cfg
export MY_SRC_RPM_BUILD_DIR=$MY_BUILD_DIR/rpmbuild
export MY_BUILD_CFG=$MY_WORKSPACE/$MY_BUILD_ENVIRONMENT_FILE
export MY_MOCK_ROOT=$MY_WORKSPACE/mock/root

if [ "$BUILD_TYPE" != "std" ]; then
   PKG_DIRS_FILE="${DISTRO}_pkg_dirs_${BUILD_TYPE}"
fi

echo "CLEAN_FLAG=$CLEAN_FLAG"
TARGETS=$@

if [ $HELP -eq 1 ]; then
    usage
    exit 0
fi

if [ $FORMAL_FLAG -eq 1 ]; then
   export FORMAL_BUILD="yes"
fi

if [ "x$TARGETS" == "x" ] && [ $EDIT_FLAG -eq 1 ]; then
    echo "ERROR: $FUNCNAME (${LINENO}): a package name is required when --edit is specified"
    usage
    exit 0
fi

SRC_ROOT="$MY_REPO"
if [ "x$MY_REPO" == "x" ]; then
   SRC_ROOT=$INITIAL_DIR
fi

BUILD_ROOT="$MY_WORKSPACE"
if [ "x$MY_WORKSPACE" == "x" ]; then
   BUILD_ROOT="$MY_PATCH_WORKSPACE"

   if [ "x$MY_PATCH_WORKSPACE" == "x" ]; then
       echo "ERROR: $FUNCNAME (${LINENO}): require one of MY_WORKSPACE or MY_PATCH_WORKSPACE be defined"
       exit 1
   fi
fi

export CCACHE_DIR="$BUILD_ROOT/.ccache"
export SRC_BASE="$SRC_ROOT"
export STX_BASE="$SRC_BASE/stx"
export CGCS_BASE="$STX_BASE"
export SPECS_BASE="$ORIG_SPECS_PATH"
export FILES_BASE="$FILES_PATH"
export PATCHES_BASE="$PATCHES_PATH"

export BUILD_BASE="$BUILD_ROOT"
BUILD_INPUTS="$BUILD_BASE/inputs"
SRPM_ASSEMBLE="$BUILD_BASE/srpm_assemble"
SRPM_WORK="$BUILD_BASE/srpm_work"

if [ "x$MY_SRC_RPM_BUILD_DIR" != "x" ]; then
    RPM_BUILD_ROOT=$MY_SRC_RPM_BUILD_DIR
else
    RPM_BUILD_ROOT=$BUILD_BASE/rpmbuild
fi

create_output_dirs

export RPM_BUILD_BASE="$RPM_BUILD_ROOT"
export SRPM_OUT="$RPM_BUILD_BASE/SRPMS"
export SOURCE_OUT="$RPM_BUILD_BASE/SOURCES"
export RPM_DIR="$RPM_BUILD_BASE/RPMS"

if [ ! -d $CGCS_BASE ]; then
   echo "ERROR: $FUNCNAME (${LINENO}): expected to find directory at '$CGCS_BASE'"
   exit 1
fi

if [ ! -d $BUILD_BASE ]; then
   echo "ERROR: $FUNCNAME (${LINENO}): expected to find directory at '$BUILD_BASE'"
   exit 1
fi

RELEASE_INFO_FILE=$STX_BASE/stx-integ/utilities/build-info/release-info.inc
if [ -f $RELEASE_INFO_FILE ]; then
   source $RELEASE_INFO_FILE
else
   echo "ERROR: $FUNCNAME (${LINENO}): failed to find RELEASE_INFO_FILE=$RELEASE_INFO_FILE"
   exit 1
fi

if [ "x$PLATFORM_RELEASE" == "x" ]; then
   echo "ERROR: $FUNCNAME (${LINENO}): PLATFORM_RELEASE is not defined in $RELEASE_INFO_FILE"
   exit 1
fi

export PLATFORM_RELEASE

mkdir -p $RPM_BUILD_BASE
if [ $? -ne 0 ]; then
   echo "ERROR: $FUNCNAME (${LINENO}): Failed to create directory '$RPM_BUILD_BASE'"
   exit 1
fi

mkdir -p $SRPM_OUT
if [ $? -ne 0 ]; then
   echo "ERROR: $FUNCNAME (${LINENO}): Failed to create directory '$SRPM_OUT'"
   exit 1
fi

mkdir -p $RPM_DIR
if [ $? -ne 0 ]; then
   echo "ERROR: $FUNCNAME (${LINENO}): Failed to create directory '$RPM_DIR'"
   exit 1
fi

build_dir () {
   local d=$1
   local w=$2
   export PKG_BASE=$d
   export WORK_BASE=$w
   export SPECS_BASE="$PKG_BASE/$ORIG_SPECS_PATH"
   local RC

   local ORIG_DIR=$(pwd)
   # echo "build_dir: PKG_BASE=$PKG_BASE"

   cd "$PKG_BASE"
   if [ $? -ne 0 ]; then
      echo "ERROR: $FUNCNAME (${LINENO}): failed to cd into '$PKG_BASE'"
      return 1
   fi

   if [ ! -d $ORIG_SPECS_PATH ]; then
      # nothing to do
      echo "WARNING: '$ORIG_SPECS_PATH' not found in '$PKG_BASE'"
      cd "$ORIG_DIR"
      return 0
   fi

   SRPM_COUNT=0
   ORIG_SRPM_PATH=""
   if [ -f $SRPM_LIST_PATH ]; then
      # we've found a file (ex centos/srpm_path) which lists a path to a source
      # RPM file
      #
      # The specified file can be of the form
      #
      # repo:path/to/file.src.rpm
      # mirror:path/to/file.src.rpm
      # /path/to/file.rpm
      # path/to/file.rpm
      #
      # If "repo:" is specified, then we search for the file relative to
      # $REPO_DOWNLOADS_ROOT (i.e. a path to the file in a "downloads subgit)
      #
      # If "mirror:" is specified, then we search for the file relateive to
      # $MIRROR_ROOT 
      #
      # If "3rd_party:" is specified, then we search for the file relateive to
      # $THIRD_PARTY_ROOT 
      #
      # An absolute path is parsed as an absolute path (mainly intended for
      # developer/experimental use without checking in files or messing with
      # your git repos)
      #
      # A lack of prefix (relative path name) is interpretted as "mirror:"
      # (legacy support for existing packages)
      #
      # Other prefixes (file:, http:, whatever:)are unsupported at this time

      for p in $(grep -v '^#' $SRPM_LIST_PATH | grep -v '^$'); do
         # absolute path source rpms
         echo "$p" | grep "^/" >/dev/null && ORIG_SRPM_PATH=$p

         if [ "${ORIG_SRPM_PATH}x" == "x" ]; then
            # handle repo: definitions
            echo "$p" | grep "^repo:" >/dev/null && ORIG_SRPM_PATH=$(echo $p | sed "s%^repo:%$REPO_DOWNLOADS_ROOT/%")
         fi

         if [ "${ORIG_SRPM_PATH}x" == "x" ]; then
            # handle 3rd_party: definitions
            echo "$p" | grep "^3rd_party:" >/dev/null && ORIG_SRPM_PATH=$(echo $p | sed "s%^3rd_party:%$THIRD_PARTY_ROOT/%")
         fi

         if [ "${ORIG_SRPM_PATH}x" == "x" ]; then
            # handle mirror: definitions
            echo "$p" | grep "^mirror:" >/dev/null && ORIG_SRPM_PATH=$(echo $p | sed "s%^mirror:%$MIRROR_ROOT/%" |  sed "s#CentOS/tis-r3-CentOS/kilo/##" | sed "s#CentOS/tis-r3-CentOS/mitaka/##")
         fi

         if [ "${ORIG_SRPM_PATH}x" == "x" ]; then
            # we haven't found a valid prefix yet, so assume it's a legacy
            # file (mirror: interpretation)
            ORIG_SRPM_PATH="$MIRROR_ROOT/$p"
         fi

         # echo "ORIG_SRPM_PATH=$ORIG_SRPM_PATH"
         if [ -f $ORIG_SRPM_PATH ]; then
             SRPM_COUNT=$((SRPM_COUNT + 1))
         else
             echo "ERROR: $FUNCNAME (${LINENO}): Invalid srpm path '$p', evaluated as '$ORIG_SRPM_PATH', found in '$PKG_BASE/$SRPM_LIST_PATH'"
             ORIG_SRPM_PATH=""
             return 3
         fi 
      done
   fi

   # Clean up an tmp_spec_*.spec file left by a prior failed build
   for f in $(find $ORIG_SPECS_PATH -name 'tmp_spec_*.spec'); do 
      \rm -f $f
   done

   SPEC_COUNT=$(find $ORIG_SPECS_PATH -name '*.spec' | wc -l)
   if [ $SPEC_COUNT -eq 0 ]; then
      if [ -f $ORIG_SPECS_PATH/spec_path ]; then
         SPECS_BASE=$SRC_BASE/$(cat $SPECS_BASE/spec_path)
         SPEC_COUNT=$(find $SPECS_BASE -maxdepth 1 -name '*.spec' | wc -l)
      fi
   fi

   if [ $SPEC_COUNT -eq 0 ] && [ $SRPM_COUNT -eq 0 ]; then
      # nothing to do
      echo "ERROR: $FUNCNAME (${LINENO}): Neither srpm_path nor .spec file not found in '$PKG_BASE/$ORIG_SPECS_PATH'"
      cd "$ORIG_DIR"
      return 0
   fi


   if [ $SPEC_COUNT -gt 0 ] && [ $SRPM_COUNT -gt 0 ]; then
      # nothing to do
      echo "ERROR: $FUNCNAME (${LINENO}): Please provide only one of srpm_path or .spec files, not both, in '$PKG_BASE/$ORIG_SPECS_PATH'"
      cd $ORIG_DIR
      return 0
   fi

   if [  $SPEC_COUNT -gt 0 ]; then
      build_dir_spec
      RC=$?
      cd "$ORIG_DIR"
      return $RC
   else
      build_dir_srpm $ORIG_SRPM_PATH
      RC=$?
      cd "$ORIG_DIR"
      return $RC
   fi

   cd "$ORIG_DIR"
   return 0
}


clean_srpm_dir () {
   local DIR=$1
   local EXCLUDE_MD5=$2
   local SRPM_PATH
   local SRPM_FILE
   local SRPM_OUT_PATH
   local SRPM_NAME
   local SRPM_OUT_NAME
   local INPUTS_TO_CLEAN=""

   if [ "$EXCLUDE_MD5" == "" ]; then
       EXCLUDE_MD5=0
   fi

   echo "clean_srpm_dir DIR=$DIR"

   INPUTS_TO_CLEAN=$(dirname $(dirname $DIR))
   echo "$INPUTS_TO_CLEAN" | grep -q "^$BUILD_INPUTS/"
   if [ $? -ne 0 ] ; then
       INPUTS_TO_CLEAN=""
   fi

   for SRPM_PATH in $(find "$DIR" -name '*.src.rpm'); do
       SRPM_FILE=$(basename $SRPM_PATH)
       SRPM_NAME=$(rpm -q --queryformat '%{NAME}\n' --nosignature -p $SRPM_PATH 2>> /dev/null)
       \rm -fv $SRPM_PATH $SRPM_OUT/$SRPM_FILE
       if [ -d $SRPM_ASSEMBLE/$SRPM_NAME ]; then
           echo "rm -rf $SRPM_ASSEMBLE/$SRPM_NAME"
           \rm -rf $SRPM_ASSEMBLE/$SRPM_NAME
       fi

       if [ -d $SOURCE_OUT/$SRPM_FILE ]; then
           echo "rm -rf $SOURCE_OUT/$SRPM_FILE"
           \rm -rf $SOURCE_OUT/$SRPM_FILE
       fi

       if [ $EXCLUDE_MD5 -eq 0 ] && [ -d $SOURCE_OUT/$SRPM_NAME ]; then
           echo "rm -rf $SOURCE_OUT/$SRPM_NAME"
           \rm -rf $SOURCE_OUT/$SRPM_NAME
       fi

       local d
       local src_d
       local spec
       local spec_name

       for d in $(find $BUILD_INPUTS -type d -name "${SRPM_NAME}*") ;do
           src_d=$(echo $d | sed "s#^$BUILD_INPUTS/#$MY_REPO/#")

           for spec in $(find $src_d/${DISTRO} -name '*.spec'); do
               spec_name=$(spec_find_tag Name $spec)
               if [ "$spec_name" == "$SRPM_NAME" ]; then
                   INPUTS_TO_CLEAN=$(if [ "x$INPUTS_TO_CLEAN" != "x" ]; then echo $INPUTS_TO_CLEAN; fi; echo "$d")
               fi
           done
       done

       # Look for older versions of the same src rpm that also need cleaning
       for SRPM_OUT_PATH in $(ls -1 $SRPM_OUT/$SRPM_NAME*.src.rpm 2>> /dev/null); do
           SRPM_OUT_FILE=$(basename $SRPM_OUT_PATH)
           SRPM_OUT_NAME=$(rpm -q --queryformat '%{NAME}\n' -p $SRPM_OUT_PATH 2>> /dev/null)
           if [ "$SRPM_NAME" == "$SRPM_OUT_NAME" ]; then
              \rm -fv $SRPM_OUT_PATH
              if [ -d $SOURCE_OUT/$SRPM_OUT_FILE ]; then
                  echo "rm -rf $SOURCE_OUT/$SRPM_OUT_FILE"
                  \rm -rf $SOURCE_OUT/$SRPM_OUT_FILE
              fi

           fi
       done
   done

   if [ "x$INPUTS_TO_CLEAN" != "x" ]; then
       for d in $INPUTS_TO_CLEAN; do
           if [ -d $d/rpmbuild ]; then
               echo "rm -rf $d"
               \rm -rf $d
           fi
       done
   fi
}

build_dir_srpm () {
   local ORIG_SRPM_PATH=$1

   local ORIG_SRPM=$(basename $ORIG_SRPM_PATH)
   local NAME=$(rpm -q --queryformat '%{NAME}\n' --nosignature -p $ORIG_SRPM_PATH)
   local PKG_NAME_VER=$(rpm -q --queryformat '%{NAME}-%{VERSION}-%{RELEASE}\n' --nosignature -p $ORIG_SRPM_PATH)
   local PKG_DIR="$NAME"
   local TARGET_FOUND=""
   local RC=0

   export SRPM_EXPORT_NAME=$NAME
   export SRPM_EXPORT_VER=$VER

   local NEED_BUILD=0

   if [ "x$TARGETS" == "x" ]; then
      NEED_BUILD=1
      TARGET_FOUND=$NAME
   else
      TARGET_LIST=( $TARGETS )
      TARGET_FOUND=$(srpm_match_target_list TARGET_LIST  "$ORIG_SRPM_PATH" 2>> /dev/null)
      if [ $? -eq 0 ]; then
         echo "found target '$TARGET_FOUND' in '$ORIG_SRPM'"
         NEED_BUILD=1
         UNRESOLVED_TARGETS=$(echo "$UNRESOLVED_TARGETS" | sed "s/\(^\|[[:space:]]\)$TARGET_FOUND\([[:space:]]\|$\)/ /g")
      fi
   fi

   if [ $NEED_BUILD -eq 0 ]; then
      return 0
   fi

   local ROOT_DIR="$SRPM_ASSEMBLE"   
   if [ $EDIT_FLAG -eq 1 ]; then
      mkdir -p $SRPM_WORK
      ROOT_DIR="$SRPM_WORK"
   fi
   local PKG_ROOT_DIR="$ROOT_DIR/$PKG_DIR"   
   local BUILD_DIR="$PKG_DIR/rpmbuild"
   local FULL_BUILD_DIR="$ROOT_DIR/$BUILD_DIR"
   local SRPM_DIR="$FULL_BUILD_DIR/SRPMS"
   local SOURCES_DIR="$SOURCE_OUT"
   
   if [ $CLEAN_FLAG -eq 1 ]; then
      # clean
      echo "===== Cleaning '$TARGET_FOUND' ====="

      if [ -d $SRPM_DIR ] && [ $EDIT_FLAG -eq 0 ]; then
         clean_srpm_dir "$SRPM_DIR" 0
      fi

      if [ -d $PKG_ROOT_DIR ]; then
          echo "rm -rf $PKG_ROOT_DIR"
          \rm -rf "$PKG_ROOT_DIR"
      fi
   else
      #build
      echo "===== Build SRPM for '$TARGET_FOUND' ====="
      echo "PKG_BASE=$PKG_BASE"
      echo "BUILD_DIR=$BUILD_DIR"
      echo "SRPM_DIR=$SRPM_DIR"

      if [ ! -d $ROOT_DIR ]; then
         mkdir -p "$ROOT_DIR"
         if [ $? -ne 0 ]; then
            echo "ERROR: $FUNCNAME (${LINENO}): mkdir '$ROOT_DIR' failed"
            return 1
         fi
      fi

      #
      # Load data from build_srpm.data
      #
      export DATA="$DATA_PATH/$SRPM_DATA"
      local COPY_LIST
      local COPY_LIST_TO_TAR
      local SRC_DIR
      local TIS_PATCH_VER
      local BUILD_IS_BIG=0
      local BUILD_IS_SLOW=0

      if [ -f $DATA ]; then
          srpm_source_build_data $DATA
          if [ $? -ne 0 ]; then
              echo "ERROR: $FUNCNAME (${LINENO}): failed to source $DATA"
              return 1
          fi
      fi

      #
      # Capture md5 data for all input files
      #
      local TARGET_SOURCES_DIR="$SOURCES_DIR/$TARGET_FOUND"
      local INPUT_FILES_MD5="$TARGET_SOURCES_DIR/srpm_input.md5"
      local REFERENCE_MD5="$TARGET_SOURCES_DIR/srpm_reference.md5"

      mkdir -p "$TARGET_SOURCES_DIR"
      md5sums_from_input_vars "$SRC_BUILD_TYPE_SRPM" "$ORIG_SRPM_PATH" "$TARGET_SOURCES_DIR" > "$INPUT_FILES_MD5"
      if [ $? -ne 0 ]; then
         echo "ERROR: $FUNCNAME (${LINENO}): md5sums_from_input_vars '$SRC_BUILD_TYPE_SRPM' '$ORIG_SRPM_PATH' '$TARGET_SOURCES_DIR'"
         return 1
      fi
      echo "Wrote: $INPUT_FILES_MD5"

      #
      # Is a rebuild required?
      # Compare md5 of current inputs vs md5 of previous build?
      #
      local BUILD_NEEDED=0
      local SRPM_OUT_PATH2
      local DIFF_LINE
      local DIFF_FILE


      if [ -f $REFERENCE_MD5 ]; then
         DIFF_LINE=$(diff "$INPUT_FILES_MD5" "$REFERENCE_MD5" | head -n 2 | tail -n 1; exit ${PIPESTATUS[0]})
         if [ $? -ne 0 ]; then
            DIFF_FILE=$(echo "$DIFF_LINE" | cut -d ' ' -f4-)
            BUILD_NEEDED=1
            case ${DIFF_LINE:0:1} in
               '>') echo "Rebuild required due to deleted file: $DIFF_FILE" ;;
               '<') echo "Rebuild required due to new or changed file: $DIFF_FILE" ;;
               *)  echo "Rebuild required due to diff: $DIFF_LINE" ;;
            esac
         fi
      else
         echo "Rebuild required due to missing reference md5: $REFERENCE_MD5"
         BUILD_NEEDED=1
      fi

      if [ -d "$FULL_BUILD_DIR/SRPMS" ]; then
         for SRPM_PATH in $(find "$FULL_BUILD_DIR/SRPMS" -name '*.src.rpm' | sort -V); do
            b=$(basename $SRPM_PATH)
            SRPM_OUT_PATH2=$(find $SRPM_OUT -name $b)
            if [ "x$SRPM_OUT_PATH2" == "x" ]; then
               echo "Rebuild required due to missing srpm: $b"
               BUILD_NEEDED=1
            fi
         done
      else
         echo "Rebuild required due to missing directory: '$FULL_BUILD_DIR/SRPMS'"
         BUILD_NEEDED=1
      fi
   
      if [ $BUILD_NEEDED -eq 0 ]; then
         echo "SRPM build not required for '$PKG_BASE'"
         echo "===== Build complete for '$TARGET_FOUND' ====="
         echo
         return 0
      fi
   
      if [ $EDIT_FLAG -eq 0 ]; then
         clean_srpm_dir "$FULL_BUILD_DIR/SRPMS" 1

         if [ -d $PKG_ROOT_DIR ]; then
            echo "rm -rf $PKG_ROOT_DIR"
            \rm -rf $PKG_ROOT_DIR
         fi
      fi

      if [ $EDIT_FLAG -eq 1 ]; then
         PKG_CLASSIFICATION=$(classify $PKG_BASE)
         echo "$PKG_CLASSIFICATION = classify $PKG_BASE"
         if [ "$PKG_CLASSIFICATION" == "spec + tarball" ] || [ "$PKG_CLASSIFICATION" == "srpm + patches" ]; then
            echo "OK to edit $PKG_BASE"
         else
            echo "Can't edit this package, it is of type '$PKG_CLASSIFICATION', it is not derived from SRPM or tarball and patches"
            return 1
         fi

         echo "srpm_extract_to_git '$ORIG_SRPM_PATH' '$PKG_BASE' '$ROOT_DIR' '$BUILD_DIR' '$PKG_NAME_VER' '$NO_META_PATCH_FLAG' '$TIS_PATCH_VER'"
         srpm_extract_to_git $ORIG_SRPM_PATH $PKG_BASE $ROOT_DIR $BUILD_DIR $PKG_NAME_VER $NO_META_PATCH_FLAG $TIS_PATCH_VER
         RC=$?
         if [ $RC -ne 0 ]; then
            if [ $RC -eq 1 ]; then
               echo "ERROR: $FUNCNAME (${LINENO}): failed to extract srpm '$ORIG_SRPM_PATH'"
            fi
            return $RC
         fi

         local LOC
         LOC=$(git_list_containing_tag "${PKG_ROOT_DIR}/gits" "pre_wrs_$PKG_NAME_VER" | head -n 1 )
         echo "===== '$TARGET_FOUND' has been extracted for editing. ====="
         echo "===== Metadata can be found at: $PKG_ROOT_DIR/rpmbuild"
         echo "===== Source code can be found at: $LOC"
         return 0
      fi

      #
      # Find age of youngest input file.
      # We will apply this as the creation/modification timestamp of the src.rpm we produce.
      #
      AGE=$(find $PKG_BASE $ORIG_SRPM_PATH -type f -exec stat --format '%Y' "{}" \; | grep -v '[/][.]git$' | grep -v '[/][.]git[/]' | sort -nr | head -n 1)
      if [ -f $PKG_BASE/$DATA ]; then
         AGE2=$(
               cd $PKG_BASE
               PATH_LIST=""

               # NOTE: SRC_DIR is not honored in this build path
      
               if [ "x$COPY_LIST" != "x" ]; then
                  PATH_LIST="$PATH_LIST $COPY_LIST"
               fi
      
               # NOTE: COPY_LIST_TO_TAR is not honored in this build path

      
               if [ "x$PATH_LIST" == "x" ]; then
                  echo "0"
               else
                  AGE2=$(find $PATH_LIST -type f -exec stat --format '%Y' "{}" \; | grep -v '[/][.]git$' | grep -v '[/][.]git[/]' | sort -nr | head -n 1)
                  echo  "$AGE2"
               fi
               )
          if [ $AGE2 -gt $AGE ]; then
             AGE=$AGE2
          fi
      fi
      
      srpm_extract $ORIG_SRPM_PATH $PKG_BASE $ROOT_DIR $BUILD_DIR $PKG_NAME_VER
      if [ $? -ne 0 ]; then
         echo "ERROR: $FUNCNAME (${LINENO}): failed to extract srpm '$ORIG_SRPM_PATH'"
         return 1
      fi

      if [ "x$COPY_LIST" != "x" ]; then
         echo "COPY_LIST: $COPY_LIST"
         for p in $COPY_LIST; do
            # echo "COPY_LIST: $p"
            \cp -L -r -f -v $p $FULL_BUILD_DIR/SOURCES
            if [ $? -ne 0 ]; then
               echo "ERROR: $FUNCNAME (${LINENO}): COPY_LIST: file not found: '$p'"
               return 1
            fi
         done
      fi

      srpm_assemble $FULL_BUILD_DIR $TIS_PATCH_VER
      if [ $? -ne 0 ]; then
         echo "ERROR: $FUNCNAME (${LINENO}): failed to assemble srpm for '$PKG_NAME_VER'"
         SRPM_FAILED_REBUILD_LIST="$SRPM_FAILED_REBUILD_LIST $TARGET_FOUND"
         return 1
      fi

      TS=$(date -d @$AGE +%Y-%m-%dT%H:%M:%S)
      for s in $(find $FULL_BUILD_DIR/SRPMS -name '*.src.rpm'); do
         \cp -L -f -v $s $SRPM_OUT/
         ss=$(basename $s)
         touch $SRPM_OUT/$ss --date=$TS

         mkdir -p $SOURCES_DIR/$ss
         BIG_FLAG_FILE="$SOURCES_DIR/$ss/BIG"
         SLOW_FLAG_FILE="$SOURCES_DIR/$ss/SLOW"

         if [ $BUILD_IS_BIG -gt 0 ]; then
             echo "$BUILD_IS_BIG" > $BIG_FLAG_FILE
         else
             if [ -f $BIG_FLAG_FILE ]; then
                 \rm -f $BIG_FLAG_FILE
             fi
         fi

         if [ $BUILD_IS_SLOW -gt 0 ]; then
             echo "$BUILD_IS_SLOW" > $SLOW_FLAG_FILE
         else
             if [ -f $SLOW_FLAG_FILE ]; then
                 \rm -f $SLOW_FLAG_FILE
             fi
         fi

         \rm -f -v "$REFERENCE_MD5"
         \mv -v "$INPUT_FILES_MD5" "$REFERENCE_MD5"

         local SPEC_DIR=$(spec_cache_dir_from_srpm $SRPM_OUT/$ss)
         if [ -d $SPEC_DIR/BUILDS_VR ]; then
            for f in $(ls -1 $SPEC_DIR/BUILDS_VR); do
                for r in $(find  $RPM_DIR -name "$f*rpm" 2>> /dev/null); do
                   \rm -f -v $r
                done
            done
         fi

         local RESULT_DIR=$(result_dir_from_srpm $SRPM_OUT/$ss)
         if [ -d $RESULT_DIR ]; then
             echo "rm -rf $RESULT_DIR"
             \rm -rf $RESULT_DIR
         fi
      done

      SRPM_REBUILT_LIST="$SRPM_REBUILT_LIST $TARGET_FOUND"
      echo "SRPM build successful for '$PKG_NAME_VER'"
      echo "===== Build complete for '$TARGET_FOUND' ====="
      echo

   fi

   return 0
}


build_dir_spec () {
   local NEED_BUILD=0
   local TARGET_FOUND=""

   if [ "x$TARGETS" == "x" ]; then
      NEED_BUILD=1
      for f in $(find $SPECS_BASE -maxdepth 1 -name '*.spec'); do
         TARGET_FOUND=$(spec_find_tag Name "$f" 2>> /dev/null)
         if [ $? -ne 0 ]; then
             TARGET_FOUND=$(spec_find_global service "$f" 2>> /dev/null)
             if [ $? -ne 0 ]; then
                 TARGET_FOUND=""
             fi
         fi
      done
   else
      TARGET_LIST=( $TARGETS )
      for f in $(find $SPECS_BASE -maxdepth 1 -name '*.spec' 2>> /dev/null); do
         TARGET_FOUND=$(spec_match_target_list TARGET_LIST "$f" 2>> /dev/null)
         if [ $? -eq 0 ]; then
            echo "found target '$TARGET_FOUND' in '$f'"
            NEED_BUILD=1
            UNRESOLVED_TARGETS=$(echo "$UNRESOLVED_TARGETS" | sed "s/\(^\|[[:space:]]\)$TARGET_FOUND\([[:space:]]\|$\)/ /g")
            break
         fi
      done
   fi

   if [ $NEED_BUILD -eq 1 ]; then
      MAKE_SRPM="$SCRIPT_PATH/$SRPM_SCRIPT"
      export DATA="$DATA_PATH/$SRPM_DATA"

      export RPMBUILD_BASE="$WORK_BASE/rpmbuild"
      SRPM_PATH="$RPMBUILD_BASE/SRPMS"
      SPEC_PATH="$RPMBUILD_BASE/SPECS"
      SOURCES_PATH="$RPMBUILD_BASE/SOURCES"
      local ROOT_DIR="$RPMBUILD_BASE"
      local PKG_ROOT_DIR="$RPMBUILD_BASE"
      local SPEC=$(find $SPECS_BASE -maxdepth 1 -name '*.spec' | head -n 1)
      local NAME=$(spec_find_tag Name $SPEC)
      local PKG_NAME_VER=$(spec_name_ver_rel $SPEC)
      local PKG_DIR="$NAME"
      local BUILD_DIR="$PKG_DIR/rpmbuild"
      local FULL_BUILD_DIR="$ROOT_DIR"
      local SRPM_DIR="$FULL_BUILD_DIR/SRPMS"
      local SOURCES_DIR="$SOURCE_OUT"

      if [ $EDIT_FLAG -eq 1 ]; then
         mkdir -p $SRPM_WORK
         ROOT_DIR="$SRPM_WORK"
         PKG_ROOT_DIR="$ROOT_DIR/$PKG_DIR"   
      fi

      if [ $CLEAN_FLAG -eq 1 ]; then
         # clean
         echo "===== Cleaning '$TARGET_FOUND' ====="
         if [ -d $SRPM_PATH ] && [ $EDIT_FLAG -eq 0 ]; then
            clean_srpm_dir $SRPM_PATH 0
         fi

         if [ -d $PKG_ROOT_DIR ]; then
             echo "rm -rf $PKG_ROOT_DIR"
             \rm -rf "$PKG_ROOT_DIR"
         fi
      else
         # build
         echo "===== Build SRPM for '$TARGET_FOUND' ====="
         echo "PKG_BASE=$PKG_BASE"
         echo "WORK_BASE=$WORK_BASE"
         echo "RPMBUILD_BASE=$RPMBUILD_BASE"
         if [ ! -x $MAKE_SRPM ]; then
            if [ ! -f $DATA ]; then
                echo "expected to find an executable script at '$MAKE_SRPM' or data for the default script at '$DATA'"
                cd $INITIAL_DIR
                exit 1
            else
                MAKE_SRPM="$DEFAULT_SRPM_SCRIPT"
            fi
         fi
   
         #
         # Load data from build_srpm.data
         #
         local COPY_LIST
         local COPY_LIST_TO_TAR
         local SRC_DIR
         local OPT_DEP_LIST
         local TIS_PATCH_VER
         local BUILD_IS_BIG=0
         local BUILD_IS_SLOW=0

         if [ -f $DATA ]; then
             srpm_source_build_data $DATA
             if [ $? -ne 0 ]; then
                 echo "ERROR: $FUNCNAME (${LINENO}): failed to source $DATA"
                 return 1
             fi
         fi

         #
         # Capture md5 data for all input files
         #
         local TARGET_SOURCES_DIR="$SOURCES_DIR/$TARGET_FOUND"
         local INPUT_FILES_MD5="$TARGET_SOURCES_DIR/srpm_input.md5"
         local REFERENCE_MD5="$TARGET_SOURCES_DIR/srpm_reference.md5"

         mkdir -p "$TARGET_SOURCES_DIR"
         md5sums_from_input_vars "$SRC_BUILD_TYPE_SPEC" "$SPEC" "$TARGET_SOURCES_DIR" > "$INPUT_FILES_MD5"
         if [ $? -ne 0 ]; then
             echo "ERROR: $FUNCNAME (${LINENO}): md5sums_from_input_vars '$SRC_BUILD_TYPE_SPEC' '$SPEC' '$TARGET_SOURCES_DIR'"
             return 1
         fi
         echo "Wrote: $INPUT_FILES_MD5"

         #
         # Is a rebuild required?
         # Compare md5 of current inputs vs md5 of previous build?
         #
         local BUILD_NEEDED=0
         local SRPM_OUT_PATH2
         local DIFF_LINE
         local DIFF_FILE

         if [ -f $REFERENCE_MD5 ]; then
            DIFF_LINE=$(diff "$INPUT_FILES_MD5" "$REFERENCE_MD5" | head -n 2 | tail -n 1; exit ${PIPESTATUS[0]})
            if [ $? -ne 0 ]; then
               DIFF_FILE=$(echo "$DIFF_LINE" | cut -d ' ' -f4-)
               BUILD_NEEDED=1
               case ${DIFF_LINE:0:1} in
                  '>') echo "Rebuild required due to deleted file: $DIFF_FILE" ;;
                  '<') echo "Rebuild required due to new or changed file: $DIFF_FILE" ;;
                  *)  echo "Rebuild required due to diff: $DIFF_LINE" ;;
               esac
            fi
         else
            echo "Rebuild required due to missing reference md5: $REFERENCE_MD5"
            BUILD_NEEDED=1
         fi

         if [ -d "$FULL_BUILD_DIR/SRPMS" ]; then
            for SRPM_PATH2 in $(find "$RPMBUILD_BASE/SRPMS" -name '*.src.rpm' | sort -V); do
               b=$(basename $SRPM_PATH2)
               SRPM_OUT_PATH2=$(find $SRPM_OUT -name $b)
               if [ "x$SRPM_OUT_PATH2" == "x" ]; then
                  echo "Rebuild required due to missing srpm: $b"
                  BUILD_NEEDED=1
               fi
            done
         else
            echo "Rebuild required due to missing directory: '$FULL_BUILD_DIR/SRPMS'"
            BUILD_NEEDED=1
         fi
   
         if [ $EDIT_FLAG -eq 1 ]; then

            PKG_CLASSIFICATION=$(classify $PKG_BASE)
            echo "$PKG_CLASSIFICATION = classify $PKG_BASE"
            if [ "$PKG_CLASSIFICATION" == "spec + tarball" ] || [ "$PKG_CLASSIFICATION" == "srpm + patches" ]; then
               echo "OK to edit $PKG_BASE"
            else
               echo "Can't edit this package, it is of type '$PKG_CLASSIFICATION', it is not derived from SRPM or tarball and patches"
               return 1
            fi

            echo "tar_and_spec_extract_to_git '$SPEC' '$PKG_BASE' '$ROOT_DIR' '$BUILD_DIR' '$PKG_NAME_VER' '$NO_META_PATCH_FLAG' '$TIS_PATCH_VER'"
            tar_and_spec_extract_to_git "$SPEC" "$PKG_BASE" "$ROOT_DIR" "$BUILD_DIR" "$PKG_NAME_VER" "$NO_META_PATCH_FLAG" "$TIS_PATCH_VER"
            RC=$?
            if [ $RC -ne 0 ]; then
               if [ $RC -eq 1 ]; then
                  echo "ERROR: $FUNCNAME (${LINENO}): failed to extract srpm '$ORIG_SRPM_PATH'"
               fi
               return $RC
            fi
   
            local LOC
            LOC=$(git_list_containing_branch "${PKG_ROOT_DIR}/gits" "${PKG_NAME_VER}" | head -n 1 )
            echo "===== '$TARGET_FOUND' has been extracted for editing. ====="
            echo "===== Metadata can be found at: $PKG_ROOT_DIR/rpmbuild"
            echo "===== Source code can be found at: $LOC"
            return 0
         fi

         if [ $BUILD_NEEDED -eq 0 ]; then
            echo "SRPM build not required for '$PKG_BASE'"
            echo "===== Build complete for '$TARGET_FOUND' ====="
            echo
            return 0
         fi


         echo "MAKE_SRPM=$MAKE_SRPM"
         echo "DATA=$DATA"
   
         if [ -d "$RPMBUILD_BASE/SRPMS" ]; then
             clean_srpm_dir "$RPMBUILD_BASE/SRPMS" 1
         fi
         if [ -d $RPMBUILD_BASE ]; then
             echo "rm -rf $RPMBUILD_BASE"
             \rm -rf "$RPMBUILD_BASE"
         fi

         echo "mkdir -p $WORK_BASE $SRPM_PATH $SPEC_PATH $SOURCES_PATH"
         mkdir -p "$WORK_BASE" && \
         mkdir -p "$SRPM_PATH" && \
         mkdir -p "$SPEC_PATH" && \
         mkdir -p "$SOURCES_PATH" 
         if [ $? -ne 0 ]; then
             echo "ERROR: Failed to create directories under: $WORK_BASE"
         fi

         \cp -L -f -v $SPECS_BASE/*.spec $SPEC_PATH/
         if [ $? -ne 0 ]; then
             echo "ERROR: $FUNCNAME (${LINENO}): Failed to copy spec files from '$SPECS_BASE' to '$SPEC_PATH'"
         fi

         #
         # build
         #
         $MAKE_SRPM
         if [ $? -ne 0 ]; then
            echo "ERROR: $FUNCNAME (${LINENO}): script failed '$MAKE_SRPM'"
            SRPM_FAILED_REBUILD_LIST="$SRPM_FAILED_REBUILD_LIST $TARGET_FOUND"
            exit 1
         fi

         #
         # Find age of youngest input file.
         # We will apply this as the creation/modification timestamp of the src.rpm we produce.
         #
         AGE=$(find $PKG_BASE -type f -exec stat --format '%Y' "{}" \; | grep -v '[/][.]git$' | grep -v '[/][.]git[/]' | sort -nr | head -n 1)
         if [ -f $PKG_BASE/$DATA ]; then
            AGE2=$(
                  cd $PKG_BASE
                  PATH_LIST=""
                  if [ "x$SRC_DIR" != "x" ]; then
                     if [ -d "$SRC_DIR" ]; then
                        PATH_LIST="$PATH_LIST $SRC_DIR"
                     fi
                  fi

                  if [ "x$COPY_LIST" != "x" ]; then
                     PATH_LIST="$PATH_LIST $COPY_LIST"
                  fi

                  if [ "x$COPY_LIST_TO_TAR" != "x" ]; then
                     PATH_LIST="$PATH_LIST $COPY_LIST_TO_TAR"
                  fi

                  if [ "x$PATH_LIST" == "x" ]; then
                     echo "0"
                  else
                     AGE2=$(find $PATH_LIST -type f -exec stat --format '%Y' "{}" \; | grep -v '[/][.]git$' | grep -v '[/][.]git[/]' | sort -nr | head -n 1)
                     echo  "$AGE2"
                  fi
                  )
             if [ $AGE2 -gt $AGE ]; then
                AGE=$AGE2
             fi
         fi

         TS=$(date -d @$AGE +%Y-%m-%dT%H:%M:%S)
         for s in $(find $SRPM_PATH -name '*.src.rpm'); do
             \cp -L -f $s $SRPM_OUT/
             ss=$(basename $s)
             touch $SRPM_OUT/$ss --date=$TS

             mkdir -p $SOURCES_DIR/$ss
             BIG_FLAG_FILE="$SOURCES_DIR/$ss/BIG"
             SLOW_FLAG_FILE="$SOURCES_DIR/$ss/SLOW"

             if [ $BUILD_IS_BIG -gt 0 ]; then
                 echo $BUILD_IS_BIG >  $BIG_FLAG_FILE
             else
                 if [ -f $BIG_FLAG_FILE ]; then
                     \rm -f $BIG_FLAG_FILE
                 fi
             fi

             if [ $BUILD_IS_SLOW -gt 0 ]; then
                 echo $BUILD_IS_SLOW > $SLOW_FLAG_FILE
             else
                 if [ -f $SLOW_FLAG_FILE ]; then
                     \rm -f $SLOW_FLAG_FILE
                 fi
             fi

             \rm -f -v "$REFERENCE_MD5"
             \mv -v "$INPUT_FILES_MD5" "$REFERENCE_MD5"

             local SPEC_DIR=$(spec_cache_dir_from_srpm $SRPM_OUT/$ss)
             if [ -d $SPEC_DIR/BUILDS_VR ]; then
                for f in $(ls -1 $SPEC_DIR/BUILDS_VR); do
                    for r in $(find  $RPM_DIR -name "$f*rpm" 2>> /dev/null); do
                       \rm -f -v $r
                    done
                done
             fi

             local RESULT_DIR=$(result_dir_from_srpm $SRPM_OUT/$ss)
             if [ -d $RESULT_DIR ]; then
                 echo "rm -rf $RESULT_DIR"
                 \rm -rf $RESULT_DIR
             fi
         done

         SRPM_REBUILT_LIST="$SRPM_REBUILT_LIST $TARGET_FOUND"
         echo "===== Build complete for '$TARGET_FOUND' ====="
         echo
      fi
   fi

   return 0
}

(
echo "$CMDLINE"

if [ -L $BUILD_ROOT/repo ]; then
    REPO_DEST=$(readlink $BUILD_ROOT/repo)
    if [ "$REPO_DEST" != "$SRC_ROOT" ]; then
        echo "Error: MY_REPO changed since last build"
        echo "   old path: $REPO_DEST"
        echo "   new path: $SRC_ROOT"
        echo "Please run '$ME --clean' if you want to compile from a new source tree"
        exit 1
    fi
fi

if [ ! -L $BUILD_ROOT/repo ]; then
    ln -s $SRC_ROOT $BUILD_ROOT/repo
fi

ALL=0
UNRESOLVED_TARGETS=" "
if [ "x$TARGETS" == "x" ]; then
    echo "make: all"
    ALL=1
else
    echo "make: $TARGETS"
    UNRESOLVED_TARGETS="$TARGETS"
fi

if [ $EDIT_FLAG -eq 0 ]; then
    if [ $CLEAN_FLAG -eq 1 ]; then
        EXTRA_RPM_FLAGS=""

        if [ $NO_BUILD_INFO -eq 1 ]; then
           EXTRA_RPM_FLAGS+=" --no-build-info"
        fi

        if [ $BUILD_TYPE_FLAG -eq 1 ]; then
           EXTRA_RPM_FLAGS+=" --$BUILD_TYPE"
        fi

        if [ $ALL -eq 1 ]; then
           build-rpms-serial --clean  $EXTRA_RPM_FLAGS
           rm -f $BUILD_ROOT/repo
        else
           build-rpms-serial --clean $EXTRA_RPM_FLAGS $TARGETS
        fi
    fi
fi

for GIT_ROOT in $GIT_LIST; do
   export GIT_BASE="$GIT_ROOT"
   for p in $(cat $GIT_ROOT/$PKG_DIRS_FILE 2>> /dev/null); do
      src_dir="$GIT_ROOT/$p"
      if [ -d $src_dir ]; then
         if [ -d $src_dir/${DISTRO} ]; then
            rel_dir=$(echo $src_dir | sed "s:^$SRC_BASE::")
            work_dir="$BUILD_INPUTS$rel_dir"
            build_dir $src_dir $work_dir
            RC=$?
            if [ $RC -ne 0 ]; then
               if [ $RC -eq 1 ]; then
                  VERB="build"

                  if [ $EDIT_FLAG -eq 1 ]; then
                     VERB="edit"
                     if [ $CLEAN_FLAG -eq 1 ]; then
                        VERB="edit clean"
                     fi
                  fi

                  if [ $CLEAN_FLAG -eq 1 ]; then
                     VERB="clean"
                  fi
                  echo "ERROR: Failed to $VERB src.rpm from source at '$p'"
               fi
               exit 1
            fi
         else
            echo "ERROR: $FUNCNAME (${LINENO}): Failed to find 'centos' in '$p', found in file '$GIT_ROOT/$PKG_DIRS_FILE'"
         fi
      else
         echo "ERROR: $FUNCNAME (${LINENO}): Bad path '$p' in file '$GIT_ROOT/$PKG_DIRS_FILE'"
      fi
   done
done


AUDIT_DIR=$(mktemp -d $MY_WORKSPACE/tmp-$USER-$ME-audit-XXXXXX)

cleanup() {
    if [ -n "$AUDIT_DIR" -a -d "$AUDIT_DIR" ]; then
        echo "clean up $AUDIT_DIR"
        rm -rf $AUDIT_DIR
    fi
}

# cleanup temp files when system exiting
trap cleanup EXIT

# Try to find and clean orphaned and discontinued .src.rpm's 
if [ $ALL -eq 1 ]; then
    echo
    echo "Auditing for obsolete srpms"
    for GIT_ROOT in $GIT_LIST; do
        for p in $(cat $GIT_ROOT/$PKG_DIRS_FILE 2>> /dev/null); do
            src_dir="$GIT_ROOT/$p"
            if [ -d $src_dir ]; then
                if [ -d $src_dir/$DISTRO ]; then

                    for f in $(find $src_dir/${DISTRO} -name '*.spec' | sort -V); do
                        NAME=$(spec_find_tag Name "$f" 2>> /dev/null)
                        if [ $? -eq 0 ]; then
                            touch "$AUDIT_DIR/$NAME"
                        fi
                    done
                    if [ -f $src_dir/$SRPM_LIST_PATH ]; then

                        for p in $(grep -v '^#' $src_dir/$SRPM_LIST_PATH | grep -v '^$'); do
                           ORIG_SRPM_PATH=""
                           # absolute path source rpms
                           echo "$p" | grep "^/" >/dev/null && ORIG_SRPM_PATH=$p

                           if [ "${ORIG_SRPM_PATH}x" == "x" ]; then
                              # handle repo: definitions
                              echo "$p" | grep "^repo:" >/dev/null && ORIG_SRPM_PATH=$(echo $p | sed "s%^repo:%$REPO_DOWNLOADS_ROOT/%")
                           fi

                           if [ "${ORIG_SRPM_PATH}x" == "x" ]; then
                              # handle 3rd_party: definitions
                              echo "$p" | grep "^3rd_party:" >/dev/null && ORIG_SRPM_PATH=$(echo $p | sed "s%^3rd_party:%$THIRD_PARTY_ROOT/%")
                           fi

                           if [ "${ORIG_SRPM_PATH}x" == "x" ]; then
                              # handle mirror: definitions
                              echo "$p" | grep "^mirror:" >/dev/null && ORIG_SRPM_PATH=$(echo $p | sed "s%^mirror:%$MIRROR_ROOT/%" | sed "s#CentOS/tis-r3-CentOS/kilo/##" | sed "s#CentOS/tis-r3-CentOS/mitaka/##")
                           fi

                           if [ "${ORIG_SRPM_PATH}x" == "x" ]; then
                              # we haven't found a valid prefix yet, so assume it's a legacy
                              # file (mirror: interpretation)
                              ORIG_SRPM_PATH="$MIRROR_ROOT/$p"
                           fi

                           if [ -f $ORIG_SRPM_PATH ]; then
                               NAME=$(rpm -q --queryformat '%{NAME}\n' -p $ORIG_SRPM_PATH 2>> /dev/null)
                               if [ $? -eq 0 ]; then
                                   touch "$AUDIT_DIR/$NAME"
                               fi
                           fi
                        done
                    fi
                fi
            fi
        done
    done

    echo "Auditing for obsolete srpms Phase 2"
    for r in $(find $SRPM_OUT -name '*.src.rpm' | sort -V); do
        NAME=$(rpm -q --queryformat '%{NAME}\n' -p $r 2>> /dev/null)
        ALT_NAME=$(echo $NAME | sed "s#-$BUILD_TYPE\$##")
        FOUND=0

        if [[ -f "$AUDIT_DIR/$NAME" || ( "$BUILD_TYPE" != "std" && -f "$AUDIT_DIR/$ALT_NAME" ) ]]; then
            FOUND=1
        fi

        if [ $FOUND -eq 0 ]; then
            for INPUT_DIR in $(find $BUILD_INPUTS -name $NAME | sort -V); do
                if [ -d "$INPUT_DIR/rpmbuild/SRPMS" ]; then
                    clean_srpm_dir "$INPUT_DIR/rpmbuild/SRPMS" 0
                fi
                if [ -d $INPUT_DIR ]; then
                    echo "rm -rf $r"
                    \rm -rf $r
                fi
            done
            if [ -f $r ]; then
                \rm -f -v $r
            fi
        fi
    done
    echo "Delete $AUDIT_DIR"
    \rm -rf "$AUDIT_DIR"
fi
echo "Auditing for obsolete srpms done"

if [ $CLEAN_FLAG -eq 1 ]; then
    if [ $ALL -eq 1 ]; then
       \rm -rf $BUILD_INPUTS
       \rm -rf $SOURCE_OUT/*.src.rpm
    fi
fi

if [ $EDIT_FLAG -ne 1 ]; then
   echo "==== Update repodata ====="
   mkdir -p $SRPM_OUT/repodata
   for d in $(find -L $SRPM_OUT -type d -name repodata); do
      (cd $d/..
       \rm -rf repodata
       $CREATEREPO $(pwd)
      )
   done
   echo "==== Update repodata complete ====="
fi

FINAL_RC=0
if [ $CLEAN_FLAG -eq 0 ] && [ $EDIT_FLAG -eq 0 ]; then
    echo ""
    if [ "$SRPM_FAILED_REBUILD_LIST" != "" ]; then
       N=$(echo "$SRPM_FAILED_REBUILD_LIST" | wc -w)
       echo "Failed to build $N packages:"
       echo "   $SRPM_FAILED_REBUILD_LIST"
       FINAL_RC=1
    fi
    if [ "$SRPM_REBUILT_LIST" != "" ]; then
       N=$(echo "$SRPM_REBUILT_LIST" | wc -w)
       echo "Successfully built $N packages:"
       echo "   $SRPM_REBUILT_LIST"
       echo ""
       echo "Compiled src.rpm's can be found here: $SRPM_OUT"
    fi
    if [ "$SRPM_FAILED_REBUILD_LIST" == "" ] && [ "$SRPM_REBUILT_LIST" == "" ]; then
       echo "No packages required a rebuild"
    fi
fi


if [ "$UNRESOLVED_TARGETS" != " " ]; then
    echo ""
    echo "ERROR: $FUNCNAME (${LINENO}): failed to resolve build targets: $UNRESOLVED_TARGETS"
    FINAL_RC=1
fi

exit $FINAL_RC
) 2>&1 | stdbuf -o0 awk '{ print strftime("%H:%M:%S"), $0; fflush(); }' | tee $(date "+$MY_WORKSPACE/build-srpms-serial_%Y-%m-%d_%H-%M-%S.log") ; exit ${PIPESTATUS[0]}
