DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
source $DIR/spec-utils
source $DIR/classify

declare -A SRPM_PKG_NAME_TO_PATH
declare -a SRPM_PKG_NAMES

declare -A STD_SRPM_PKG_NAME_TO_PATH
declare -a STD_SRPM_PKG_NAMES


METHOD_NO_RPMBUILD=0
METHOD_RPMBUILD_UNPATCH=1
METHOD_RPMBUILD_SCRIPT=2



srpm_spec_find_version () {
    local SPEC_PATH="$1"
    local PKG_VER=$(spec_find_tag Version $SPEC_PATH 2>> /dev/null)

    if [ "x$PKG_VER" == "x" ]; then
        if [ "x$SRPM_EXPORT_VER" != "x" ]; then
            PKG_VER="$SRPM_EXPORT_VER"
        else
            PKG_VER="0"
        fi
    fi
    echo "$PKG_VER"
}

srpm_spec_find_name () {
    local SPEC_PATH="$1"
    local PKG_VER=$(spec_find_tag Name $SPEC_PATH 2>> /dev/null)

    if [ "x$PKG_VER" == "x" ]; then
        if [ "x$SRPM_EXPORT_NAME" != "x" ]; then
            PKG_VER="$SRPM_EXPORT_NAME"
        else
            PKG_VER="0"
        fi
    fi
    echo "$PKG_VER"
}

# Find the common root directory of a tar file.
# This form take as input command syntax to list the tar file contents.
# Prefered from is to use tar -tvf ... plus any additional args.
#   - don't use x in place of t, we don't want side effects
#   - Must use 'v' to help identif directories
tar_cmd_common_dir () {
   local TAR_EXTRACT_CMD="$1"

   local i=1
   local prev_path=""
   local path
   local count=0

   path=$(eval "$TAR_EXTRACT_CMD -v" | grep '^d')
   count=$(echo "$path" | wc -w)
   if [ $count -gt 0 ]; then
      i=1
      while [ $i -lt 25 ]; do
         path=$(eval "$TAR_EXTRACT_CMD -v" | grep '^d'  | cut -d ":" -f 2- | cut -d " " -f 2- | cut -f1-$i -d/ | uniq)
         count=$(echo "$path" | wc -l)
         if [ $count -gt 1 ]; then
            echo $prev_path
            i=0
            break
         else
            prev_path=$path
         fi
         i=$((i + 1))
      done
   else
      i=1
      while [ $i -lt 25 ]; do
         path=$(eval "$TAR_EXTRACT_CMD -v" | cut -d ':' -f 2- | cut -d ' ' -f 2- | rev | cut -d '/' -f 1 --complement | rev | cut -f1-$i -d/ | uniq)
         count=$(echo "$path" | wc -l)
         if [ $count -gt 1 ]; then
            echo $prev_path
            i=0
            break
         else
            prev_path=$path
         fi
         i=$((i + 1))
      done
   fi
   return $i
}


rpm_get_srpm () {
    local rpm_path=$1
    rpm -q --info --nosignature -p $rpm_path | grep '^Source RPM' | sed 's#^Source RPM  : ##'
}

rpm_get_name () {
   local srpm_path=$1
   rpm -q --queryformat '%{NAME}\n' --nosignature -p $srpm_path
}

rpm_get_version () {
   local srpm_path=$1
   rpm -q --queryformat '%{VERSION}\n' --nosignature -p $srpm_path
}

rpm_get_release () {
   local srpm_path=$1
   rpm -q --queryformat '%{RELEASE}\n' --nosignature -p $srpm_path
}

rpm_get_arch () {
   local srpm_path=$1
   rpm -q --queryformat '%{ARCH}\n' --nosignature -p $srpm_path
}

rpm_get_full_name () {
   local srpm_path=$1
   rpm -q --queryformat '%{NAME}-%{VERSION}-%{RELEASE}\n' --nosignature -p $srpm_path
}


raw_fix_if_ApplyPatch () {
   local RAW_SCRIPT=$1

   local TMP_SCRIPT=$(dirname $RAW_SCRIPT)/tmp_raw_script
  
   grep '^ApplyPatch ' $RAW_SCRIPT >> /dev/null
   if [ $? -eq 0 ]; then
      mv -f $RAW_SCRIPT $TMP_SCRIPT
      local COUNT=0
      while read -r LINE ; do
         case "$LINE" in
            "ApplyPatch "*)
               PN=$(echo "$LINE" | awk '{print $2}')
               COUNT=$((COUNT + 1))
               echo "echo 'Patch #$COUNT $PN'" >> $RAW_SCRIPT
               echo "$LINE" >> $RAW_SCRIPT
               ;;
            *)
               echo "$LINE" >> $RAW_SCRIPT
               ;;
         esac
      done < "$TMP_SCRIPT"
   fi
}

srpm_create_raw_extract_script () {
   local SPEC_FILE=$1
   local ROOT_DIR=$2
   local RPMBUILD_DIR=$3
   local TARGET_ARCH=$4
   local TIS_PATCH_VER=$5
   local RAW_SCRIPT=$6
   local TAR_DIR=$7

   echo "SPEC_FILE=$SPEC_FILE  ROOT_DIR=$ROOT_DIR  RPMBUILD_DIR=$RPMBUILD_DIR  TARGET_ARCH=$TARGET_ARCH  TIS_PATCH_VER=$TIS_PATCH_VER  RAW_SCRIPT=$RAW_SCRIPT  TAR_DIR=$TAR_DIR"
   local BUILD_DIR="$RPMBUILD_DIR/BUILD"
   local ApplyPatchCount=0

   if [ ! -f $SPEC_FILE ]; then
      >&2 echo "ERROR: $FUNCNAME (${LINENO}): file SPEC_FILE='$SPEC_FILE' does not exist"
      return 1
   fi

   if [ ! -d $ROOT_DIR ]; then
      >&2 echo "ERROR: $FUNCNAME (${LINENO}): directory ROOT_DIR='$ROOT_DIR' does not exist"
      return 1
   fi

   if [ ! -d $RPMBUILD_DIR ]; then
      >&2 echo "ERROR: $FUNCNAME (${LINENO}): directory RPMBUILD_DIR='$RPMBUILD_DIR' does not exist"
      return 1
   fi

   mkdir -p $BUILD_DIR
   mkdir -p $ROOT_DIR/tmp
   local STDOUT_LOG=$(mktemp /tmp/stdout_XXXXX.log)
   local STDERR_LOG=$(mktemp /tmp/stderr_XXXXX.log)
   local PREV_STDOUT_LOG=$(mktemp /tmp/stdout_XXXXX.log)
   local PREV_STDERR_LOG=$(mktemp /tmp/stderr_XXXXX.log)
   local SAME=0

   # Build the srpm as though for std build, for naming consistency
   echo "stdbuf -oL -eL rpmbuild -bp $SPEC_FILE --root $ROOT_DIR --define='%_topdir $RPMBUILD_DIR' --define='_tis_dist .tis' --define='tis_patch_ver $TIS_PATCH_VER' --nodeps --target $TARGET_ARCH > $STDOUT_LOG 2> $STDERR_LOG"
   stdbuf -oL -eL rpmbuild -bp $SPEC_FILE --root $ROOT_DIR \
      --define="%_topdir $RPMBUILD_DIR" \
      --define='_tis_dist .tis' \
      --define="tis_patch_ver $TIS_PATCH_VER" \
      --define="_tis_build_type $BUILD_TYPE" \
      --nodeps --target $TARGET_ARCH > $STDOUT_LOG 2> $STDERR_LOG
   if [ $? -ne 0 ]; then
      >&2 echo "ERROR: $FUNCNAME (${LINENO}): rpmbuild -bp failed"
      \rm -rf $STDOUT_LOG $STDERR_LOG $PREV_STDOUT_LOG $PREV_STDERR_LOG
      return 1
   fi

   # The kernel-rt spec file protects against re-extraction,
   # so we can't do multiple passes for that package.
   # Trick the loop by setting SAME=1 to bypass it
   if [ "$(basename $SPEC_FILE)" = "kernel-rt.spec" ]; then
      SAME=1
   fi

   let -i COUNT=0
   while [ $SAME -eq 0 ]; do
      \cp -f $STDOUT_LOG $PREV_STDOUT_LOG
      \cp -f $STDERR_LOG $PREV_STDERR_LOG
      stdbuf -oL -eL rpmbuild -bp $SPEC_FILE --root $ROOT_DIR \
         --define="%_topdir $RPMBUILD_DIR" \
         --define='_tis_dist .tis' \
         --define="tis_patch_ver $TIS_PATCH_VER" \
         --define="_tis_build_type $BUILD_TYPE" \
         --nodeps --target $TARGET_ARCH > $STDOUT_LOG 2> $STDERR_LOG
      if [ $? -ne 0 ]; then
         >&2 echo "ERROR: $FUNCNAME (${LINENO}): rpmbuild -bp failed"
         \rm -rf $STDOUT_LOG $STDERR_LOG $PREV_STDOUT_LOG $PREV_STDERR_LOG
         return 1
      fi
      diff $STDERR_LOG $PREV_STDERR_LOG
      if [ $? -eq 0 ]; then
         SAME=1
      fi
      let -i COUNT++
      if [ $COUNT -ge 20 ]; then 
         break; 
      fi
   done

   if [ "$TAR_DIR" == "" ]; then
       grep '^+' $STDERR_LOG | sed -e 's/^[+]* //' | grep -v "^for\>" > $RAW_SCRIPT
   else
       # Note: grep -v "^rm .*${TAR_DIR^}"  catches TAR_DIR that has been capitalized vs srpm name, like python
       grep '^+' $STDERR_LOG | sed -e 's/^[+]* //' | grep -v "^for\>" | grep -v "^rm .*${TAR_DIR}" | grep -v "^rm .*${TAR_DIR^}"  > $RAW_SCRIPT
   fi
   raw_fix_if_ApplyPatch $RAW_SCRIPT
   \rm -rf $STDOUT_LOG $STDERR_LOG $PREV_STDOUT_LOG $PREV_STDERR_LOG
   return 0
}


##
## Return patch file for the target patch number
##
raw_extract_patch_file () {
   local RAW_SCRIPT=$1
   local TARGET_PATCH_NO=$2
   local SPEC_FILE=$3

   local PATCH_FILE
   local PATCH_PATH
   if [ ! -f $RAW_SCRIPT ]; then
      >&2 echo "ERROR: $FUNCNAME (${LINENO}): file RAW_SCRIPT='$RAW_SCRIPT' does not exist"
      return 1
   fi

   PATCH_FILE=$(cat $RAW_SCRIPT | grep "echo 'Patch #$TARGET_PATCH_NO " | awk '{print $NF}' | sed  's#^(##' | sed "s#'\$##" | sed 's#):$##')
   if [ "x$PATCH_FILE" == "x" ]; then
      PATCH_PATH=$(cat $RAW_SCRIPT | grep "/usr/bin/cat " | grep "/$TARGET_PATCH_NO" | awk '{print $2}')
      if [ "x$PATCH_PATH" == "x" ]; then
          grep "^git am " $RAW_SCRIPT >> /dev/null
          if [ $? -eq 0 ]; then
             # Extract list of patches from git am command line options, then find n'th patch
             PATCH_PATH=$(grep "^git am " $RAW_SCRIPT | tr ' ' '\n' | grep '[.]patch$' | sed -n "${TARGET_PATCH_NO}p")
          else
             grep "^xargs git am" $RAW_SCRIPT >> /dev/null
             if [ $? -eq 0 ]; then
                # Extract list of patches from spec file... assume no reordering ... then find n'th patch
                PATCH_PATH=$(grep '^Patch[0-9]*:' $SPEC_FILE | sort -n | awk -F ':' '{ print $2}' | sed 's/^[ \t]*//' | sed 's/[ \t]*$//' | sed -n "${TARGET_PATCH_NO}p")
             else
                return 1
             fi
          fi
      fi
      PATCH_FILE=$(basename $PATCH_PATH)
   fi

   echo $PATCH_FILE
   return 0
}

##
## Create script to apply one patch
##
raw_create_patch_apply_script () {
   local RAW_SCRIPT=$1
   local TARGET_PATCH_NO=$2
   local PATCH_SCRIPT=$3
   local OLD_BUILD_DIR=$4
   local NEW_BUILD_DIR=$5
   local SPEC_FILE=$6
   local PATCH_COUNT_TARGET=$7

   local SOURCE_PATH=$(echo $OLD_BUILD_DIR | sed 's#/BUILD$#/SOURCES#')
   local PATCH_NO=0
   local PATCH_FILE=""
   local PATCH_PATH=""

   if [ ! -f $RAW_SCRIPT ]; then
      >&2 echo "ERROR: $FUNCNAME (${LINENO}): file RAW_SCRIPT='$RAW_SCRIPT' does not exist"
      return 1
   fi

   local COUNT_START=0
   grep "echo 'Patch #$TARGET_PATCH_NO " $RAW_SCRIPT >> /dev/null
   if [ $? -ne 0 ]; then
      grep "/usr/bin/cat " $RAW_SCRIPT | grep "/$TARGET_PATCH_NO" >> /dev/null
      if [ $? -ne 0 ]; then
          # Extract list of patches from git am command line options, then find n'th patch
          PATCH_PATH=$(grep "^git am " $RAW_SCRIPT | tr ' ' '\n' | grep '.patch$' | sed -n "${TARGET_PATCH_NO}p")
          if [ "x$PATCH_PATH" == "x" ]; then
              grep "^xargs git am" $RAW_SCRIPT >> /dev/null
              if [ $? -eq 0 ] && [ "$SPEC_FILE" != "" ]; then
                  # Extract list of patches from spec file... assume no reordering ... then find n'th patch
                  PATCH_PATH=$(grep '^Patch[0-9]*:' $SPEC_FILE | sort -n | awk -F ':' '{ print $2}' | sed 's/^[ \t]*//' | sed 's/[ \t]*$//' | sed -n "${TARGET_PATCH_NO}p")
                  if [ "x$PATCH_PATH" == "x" ]; then
                     >&2 echo "ERROR: $FUNCNAME (${LINENO}): TARGET_PATCH_NO=$TARGET_PATCH_NO does not exist in RAW_SCRIPT=$RAW_SCRIPT"
                     return 1
                  fi
              else
                 >&2 echo "ERROR: $FUNCNAME (${LINENO}): TARGET_PATCH_NO=$TARGET_PATCH_NO does not exist in RAW_SCRIPT=$RAW_SCRIPT"
                 return 1
              fi
          fi
      fi
   else
      # We know 'echo Patch #$TARGET_PATCH_NO' exists in the file, so
      # rig it so CAT_COUNT and PATCH_COUNT never match TARGET_PATCH_NO.
      # CAT_COUNT and PATCH_COUNT are a fall back when patches aren't explicitly numbered.
      COUNT_START=-20000
   fi

   if [ -f $PATCH_SCRIPT ]; then
      \rm -rf $PATCH_SCRIPT
   fi

   echo "set -e" >> $PATCH_SCRIPT
   echo "set -x" >> $PATCH_SCRIPT

   local STATE=PRE_PATCH
   local LAST_LINE=""
   local LINE=""
   local TYPICAL_PATCH=""
   local CAT_COUNT=$COUNT_START
   local PATCH_COUNT=$COUNT_START
   local RC=0

   PATCH_NO=0
   PATCH_FILE=""
   PATCH_PATH=""
   local LAST_CD=""
   local DD=""

   while read -r LINE ; do
       LINE=$(echo $LINE | sed -r "s#$(echo $OLD_BUILD_DIR | sed 's#/#[/]+#g')#$NEW_BUILD_DIR#g")
       # >&2  echo "Parse: STATE=$STATE, LINE=$LINE"
       if [[ "$LINE" == "'['"* ]]; then
          continue
       fi
       case $STATE in
          PRE_PATCH)
             case "$LINE" in
                 "echo 'Patch #"*)
                     PATCH_NO=$(echo $LINE | awk '{ print $3 }' | sed 's/#//')
                     PATCH_FILE=$(echo $LINE | awk '{ print $4 }' | sed "s/[():']//g")
                     if [ $PATCH_NO -eq $TARGET_PATCH_NO ]; then
                         STATE="PATCH_BEGIN"
                         echo $LINE >> $PATCH_SCRIPT
                     fi
                     ;;
                 "cat "*|\
                 "/usr/bin/cat "*)
                     PATCH_PATH=$(echo $LINE | awk '{ print $2 }')
                     PATCH_FILE=$(basename $PATCH_PATH)
                     PATCH_NO=$PATCH_FILE
                     CAT_COUNT=$((CAT_COUNT + 1))
                     if [ "$PATCH_NO" == "$TARGET_PATCH_NO" ] || [ "$CAT_COUNT" == "$TARGET_PATCH_NO" ] ; then
                         STATE="PATCH"
                         PATCH_NO=$TARGET_PATCH_NO
                         echo "echo 'Patch #$PATCH_NO ($PATCH_FILE):'" >> $PATCH_SCRIPT
                     fi
                     ;;
                 "/usr/bin/patch "*|\
                 "patch "*)
                     TYPICAL_PATCH="$LINE"
                     PATCH_COUNT=$((PATCH_COUNT + 1))
                     # >&2  echo "Parse: PATCH_COUNT=$PATCH_COUNT, PATCH_COUNT_TARGET=$PATCH_COUNT_TARGET, TARGET_PATCH_NO=$TARGET_PATCH_NO"
                     if [ "$PATCH_COUNT" == "$TARGET_PATCH_NO" ] || [ "$PATCH_COUNT" == "$PATCH_COUNT_TARGET" ] ; then
                         STATE="REVERSE_PATCH"
                         PATCH_NO=$TARGET_PATCH_NO
                     fi
                     ;;
                 "/usr/bin/git apply "*|\
                 "git apply "*)
                     TYPICAL_PATCH="$LINE"
                     PATCH_COUNT=$((PATCH_COUNT + 1))
                     if [ "$PATCH_COUNT" == "$TARGET_PATCH_NO" ] || [ "$PATCH_COUNT" == "$PATCH_COUNT_TARGET" ]; then
                         STATE="REVERSE_PATCH"
                         PATCH_NO=$TARGET_PATCH_NO
                     fi
                     ;;
                 "/usr/bin/git am "*|\
                 "git am "*)
                     PATCH_PATH=$(grep "^git am " $RAW_SCRIPT | tr ' ' '\n' | grep '.patch$' | sed -n "${TARGET_PATCH_NO}p")
                     if [ "x$PATCH_PATH" != "x" ]; then
                        GIT_APPLY_ARGS=""
                        GIT_AM_EXCLUDE_PENDING=0
                        GIT_AM_INCLUDE_PENDING=0
                        GIT_AM_DIRECTORY_PENDING=0
                        GIT_AM_WHITESPACE_PENDING=0
                        for GIT_AM_ARG in $(grep "^git am " $RAW_SCRIPT | tr ' ' '\n' | grep -v '.patch$'); do
                           case "$GIT_AM_ARG" in
                               "--exclude="*)
                                   GIT_APPLY_ARGS="$GIT_APPLY_ARGS $GIT_AM_ARG"
                                   ;;
                               "--exclude")
                                   GIT_AM_EXCLUDE_PENDING=1
                                   ;;
                               "--include="*)
                                   GIT_APPLY_ARGS="$GIT_APPLY_ARGS $GIT_AM_ARG"
                                   ;;
                               "--include")
                                   GIT_AM_INCLUDE_PENDING=1
                                   ;;
                               "--directory="*)
                                   DD=$(basename $(echo "$GIT_AM_ARG" | cut -d '=' -f 2))
                                   echo "DD=$DD, LAST_CD=$LAST_CD"
                                   if [ "$DD" != "$LAST_CD" ]; then
                                       GIT_APPLY_ARGS="$GIT_APPLY_ARGS $GIT_AM_ARG"
                                   fi
                                   ;;
                               "--directory")
                                   GIT_AM_DIRECTORY_PENDING=1
                                   ;;
                               "--whitespace="*)
                                   GIT_APPLY_ARGS="$GIT_APPLY_ARGS $GIT_AM_ARG"
                                   ;;
                               "--whitespace")
                                   GIT_AM_WHITESPACE_PENDING=1
                                   ;;
                               "-p"*)
                                   GIT_APPLY_ARGS="$GIT_APPLY_ARGS $GIT_AM_ARG"
                                   ;;
                               "-C"*)
                                   GIT_APPLY_ARGS="$GIT_APPLY_ARGS $GIT_AM_ARG"
                                   ;;
                               "--ignore-space-change")
                                   GIT_APPLY_ARGS="$GIT_APPLY_ARGS $GIT_AM_ARG"
                                   ;;
                               "--ignore-whitespace")
                                   GIT_APPLY_ARGS="$GIT_APPLY_ARGS $GIT_AM_ARG"
                                   ;;
                               *)
                                   if [ $GIT_AM_EXCLUDE_PENDING -eq 1 ]; then
                                       GIT_AM_EXCLUDE_PENDING=0
                                       GIT_APPLY_ARGS="$GIT_APPLY_ARGS --exclude=$GIT_AM_ARG"
                                   fi
                                   if [ $GIT_AM_INCLUDE_PENDING -eq 1 ]; then
                                       GIT_AM_INCLUDE_PENDING=0
                                       GIT_APPLY_ARGS="$GIT_APPLY_ARGS --include=$GIT_AM_ARG"
                                   fi
                                   if [ $GIT_AM_DIRECTORY_PENDING -eq 1 ]; then
                                       GIT_AM_DIRECTORY_PENDING=0
                                       DD=$(basename $(echo "$GIT_AM_ARG" | cut -d '=' -f 2))
                                       echo "DD=$DD, LAST_CD=$LAST_CD"
                                       if [ "$DD" != "$LAST_CD" ]; then
                                           GIT_APPLY_ARGS="$GIT_APPLY_ARGS --directory=$GIT_AM_ARG"
                                       fi
                                   fi
                                   if [ $GIT_AM_WHITESPACE_PENDING -eq 1 ]; then
                                       GIT_AM_WHITESPACE_PENDING=0
                                       GIT_APPLY_ARGS="$GIT_APPLY_ARGS --whitespace=$GIT_AM_ARG"
                                   fi
                                   ;;
                           esac
                        done
                        PATCH_FILE=$(basename $PATCH_PATH)
                        PATCH_NO=$TARGET_PATCH_NO
                        echo "echo 'Patch #$PATCH_NO ($PATCH_FILE):'" >> $PATCH_SCRIPT
                        # >&2 echo "echo GIT_APPLY_ARGS=$GIT_APPLY_ARGS"
                        if [ "$GIT_APPLY_ARGS" == "" ]; then
                           echo "cat $PATCH_PATH | patch -p1" >> $PATCH_SCRIPT
                        else
                           echo "git apply $GIT_APPLY_ARGS $PATCH_PATH" >> $PATCH_SCRIPT
                        fi
                        STATE="POST_PATCH"
                     fi
                     ;;
                 "xargs git am"*)
                     PATCH_SRC_DIR="$(dirname $(dirname $SPEC_FILE))/SOURCES"
                     PATCH_PATH=$(grep '^Patch[0-9]*:' $SPEC_FILE | sort -n | awk -F ':' '{ print $2}' | sed 's/^[ \t]*//' | sed 's/[ \t]*$//' | sed -n "${TARGET_PATCH_NO}p" | sed "s#^#$PATCH_SRC_DIR/#")
                     if [ "x$PATCH_PATH" != "x" ]; then
                        PATCH_FILE=$(basename $PATCH_PATH)
                        PATCH_NO=$TARGET_PATCH_NO
                        echo "echo 'Patch #$PATCH_NO ($PATCH_FILE):'" >> $PATCH_SCRIPT
                        echo "cat $PATCH_PATH | patch -p1" >> $PATCH_SCRIPT
                        STATE="POST_PATCH"
                     fi
                     ;;
                 "cd "*|\
                 "popd"*|\
                 "pushd "*)
                     echo $LINE >> $PATCH_SCRIPT
                     LAST_CD=$(basename $(echo $LINE | cut -d ' ' -f2-))
                     ;;
                 *)
                     ;;
             esac
             ;;
          PATCH_BEGIN)
             case "$LINE" in
                 "cat "*|\
                 "/usr/bin/cat "*)
                     STATE="PATCH"
                     CAT_COUNT=$((CAT_COUNT + 1))
                     PATCH_PATH=$(echo $LINE | awk '{ print $2 }')
                     ;;
                "/usr/bin/patch "*|\
                "patch "*)
                     STATE="REVERSE_PATCH"
                     PATCH_COUNT=$((PATCH_COUNT + 1))
                     TYPICAL_PATCH="$LINE"
                     ;;
                "/usr/bin/git apply "*|\
                "git apply "*)
                     STATE="REVERSE_PATCH"
                     PATCH_COUNT=$((PATCH_COUNT + 1))
                     TYPICAL_PATCH="$LINE"
                     ;;
                "ApplyPatch "*)
                     STATE="APPLYPATCH"
                     PATCH_PATH=$(echo $LINE | awk '{ print $2 }')
                     if [ ! -f $PATCH_PATH ]; then
                        PATCH_PATH="$SOURCE_PATH/$PATCH_PATH"
                     fi
                     ;;
                 *)
                     >&2 echo "ERROR: $FUNCNAME (${LINENO}): Unexpected Line in state PATCH_BEGIN: $LINE"
                     RC=1
                     break
                     ;;
             esac
             ;;
          APPLYPATCH)
             case "$LINE" in
                 "/usr/bin/patch "*|\
                 "patch "*)
                     STATE="POST_PATCH"
                     PATCH_COUNT=$((PATCH_COUNT + 1))
                     echo "/usr/bin/cat $PATCH_PATH | $LINE" >> $PATCH_SCRIPT
                     ;;
                 "/usr/bin/git apply "*|\
                 "git apply "*)
                     STATE="POST_PATCH"
                     echo "/usr/bin/cat $PATCH_PATH | $LINE" >> $PATCH_SCRIPT
                     ;;
                 *)
                     ;;
             esac
             ;;
          PATCH)
             case "$LINE" in
                 "/usr/bin/patch "*|\
                 "patch "*)
                     STATE="POST_PATCH"
                     TYPICAL_PATCH="$LINE"
                     PATCH_COUNT=$((PATCH_COUNT + 1))
                     echo "$LAST_LINE | $LINE" >> $PATCH_SCRIPT
                     ;;
                 "/usr/bin/git apply "*|\
                 "git apply "*)
                     STATE="POST_PATCH"
                     TYPICAL_PATCH="$LINE"
                     echo "$LAST_LINE | $LINE" >> $PATCH_SCRIPT
                     ;;
                 "echo 'Patch #"*)
                     STATE="POST_PATCH"
                     if [ "x$TYPICAL_PATCH" != "x" ];then
                        echo "$LAST_LINE | $TYPICAL_PATCH" >> $PATCH_SCRIPT
                     else
                        >&2 echo "ERROR: $FUNCNAME (${LINENO}): Unexpected Line in state PATCH: $LINE"
                        RC=1
                        break
                     fi
                     ;;
                 *)
                     >&2 echo "WARNING: * TYPICAL_PATCH=$TYPICAL_PATCH"
                     >&2 echo "ERROR: $FUNCNAME (${LINENO}): Unexpected Line in state PATCH: $LINE"
                     RC=1
                     break
                     ;;
             esac
             ;;
          REVERSE_PATCH)
             case "$LINE" in
                 "cat "*|\
                 "/usr/bin/cat "*)
                     STATE="POST_PATCH"
                     CAT_COUNT=$((CAT_COUNT + 1))
                     PATCH_PATH=$(echo $LINE | awk '{ print $2 }')
                     PATCH_FILE=$(basename $PATCH_PATH)
                     echo "echo 'Patch #$PATCH_NO ($PATCH_FILE):'" >> $PATCH_SCRIPT
                     echo "$LINE | $LAST_LINE" >> $PATCH_SCRIPT
                     ;;
                 *)
                     # Not sure why, but the 'cat' line gets dropped on rare and hard to reproduce occasions.
                     # Recreate it here if we can.
                     PATCH_PATH="$SOURCE_PATH/PATCH_FILE"
                     if [ -f "$PATCH_PATH" ]; then
                        >&2 echo "ERROR: $FUNCNAME (${LINENO}): Assuming PATCH_PATH=$PATCH_PATH"
                        STATE="POST_PATCH"
                        echo "/usr/bin/cat $PATCH_PATH | $LAST_LINE" >> $PATCH_SCRIPT
                     else
                        >&2 echo "ERROR: $FUNCNAME (${LINENO}): Unexpected Line in state REVERSE_PATCH: $LINE"
                        RC=1
                        break
                     fi
                     ;;
             esac
             ;;
          POST_PATCH)
             case "$LINE" in
                 "cd "*|\
                 "popd"*|\
                 "pushd "*)
                     echo $LINE >> $PATCH_SCRIPT
                     ;;
                 *)
                     ;;
             esac
             ;;
   
      esac
      LAST_LINE="$LINE"
   done < "$RAW_SCRIPT"

   return $RC
}

##
## script to extract tarballs 
##
raw_create_tarballs_extract_script () {
   local RAW_SCRIPT=$1
   local EXTRACT_SCRIPT=$2
   local OLD_BUILD_DIR=$3
   local NEW_BUILD_DIR=$4

   if [ ! -f $RAW_SCRIPT ]; then
      >&2 echo "ERROR: $FUNCNAME (${LINENO}): file RAW_SCRIPT='$RAW_SCRIPT' does not exist"
      return 1
   fi

   if [ -f $EXTRACT_SCRIPT ]; then
      \rm -rf $EXTRACT_SCRIPT
   fi

   local STATE="PRE_PATCH"
   local LAST_LINE=""
   local RC=0
   local FIRST_TAR=0
   local EXTRACT_DIR=""
   local EXTRACT_TAR_DIR=""
   local EXTRACT_TAR_DIR_NOW=""
   local MV_DEST=""
   local CURR_DIR=""
   local PREV_DIR=""
   local DEST
   local TAR_ARGS
   local POST_PATCH_FIRST_PASS=0

   echo "set -e" >> $EXTRACT_SCRIPT
   echo "set -x" >> $EXTRACT_SCRIPT

   while read -r LINE ; do
      LINE=$(echo $LINE | sed -r "s#$(echo $OLD_BUILD_DIR | sed 's#/#[/]+#g')#$NEW_BUILD_DIR#g")
      # >&2 echo "Parse: STATE=$STATE, LINE=$LINE"
      if [[ "$LINE" == "'['"* ]]; then
         # kernel-rt hack
         if [[ "$LINE" == "'[' -L vanilla-3.10.0/configs ']'" ]]; then
            echo "if [ -L vanilla-3.10.0/configs ]; then rm -f vanilla-3.10.0/configs; fi" >> $EXTRACT_SCRIPT
         fi
         # kernel hack
         if [[ "$LINE" == "'[' -L configs ']'" ]]; then
            echo "if [ -L configs ]; then rm -f configs; fi" >> $EXTRACT_SCRIPT
         fi
         continue
      fi
      case $STATE in
         PRE_PATCH)
            case "$LINE" in
                "ApplyOptionalPatch"*|\
                "ApplyPatch"*|\
                "echo 'Patch #"*)
                    STATE="POST_PATCH"
                    ;;
                "gzip -dc "*|\
                "xz -dc "*|\
                "bzip2 -dc "*|\
                "/usr/bin/gzip -dc "*|\
                "/usr/bin/xz -dc "*|\
                "/usr/bin/bzip2 -dc "*)
                    STATE="TAR"
                    ;;
                "tar -xf -"|\
                "tar -xvf -"|\
                "tar -xvvf -"|\
                "tar -xo -f -"|\
                "/usr/bin/tar -xf -"|\
                "/usr/bin/tar -xvf -"|\
                "/usr/bin/tar -xvvf -"|\
                "/usr/bin/tar -xo -f -") 
                    LINE="$LINE --exclude .git"
                    STATE="REVERSE_TAR"
                    ;;
                "tar -xf "*|\
                "tar -xvf "*|\
                "tar -xvvf "*|\
                "tar -xo -f "*|\
                "/usr/bin/tar -xf "*|\
                "/usr/bin/tar -xvf "*|\
                "/usr/bin/tar -xvvf "*|\
                "/usr/bin/tar -xo -f "*)
                    echo "$LINE --exclude .git" >> $EXTRACT_SCRIPT
                    if [ $FIRST_TAR -eq 0 ]; then
                       TAR_ARGS=$(echo $LINE | sed -e 's#^/usr/bin/tar ##' -e 's#^tar ##' -e 's#^-xf ##' -e 's#^-xvf ##' -e 's#^-xvvf ##' -e 's#^-xo -f ##')
                       EXTRACT_DIR=$(dirname $EXTRACT_SCRIPT)/extract_dir
                       EXTRACT_TAR_DIR=$(dirname $EXTRACT_SCRIPT)/tar_dir
                       EXTRACT_TAR_DIR_NOW=$(tar_cmd_common_dir "tar -tvf $TAR_ARGS")
                       echo "readlink -f \$(pwd) > $EXTRACT_DIR" >> $EXTRACT_SCRIPT
                    fi
                    FIRST_TAR=1
                    ;;

                "git am "*)
                    STATE="POST_PATCH"
                    ;;
                "xargs git am"*)
                    STATE="POST_PATCH"
                    ;;
                "/usr/bin/patch "*|\
                "patch "*)
                    STATE="POST_PATCH"
                    ;;
                "/usr/bin/git apply "*|\
                "git apply "*)
                    STATE="POST_PATCH"
                    ;;
                "mv $EXTRACT_TAR_DIR_NOW "*)
                    if [ "x$EXTRACT_TAR_DIR_NOW" == "x" ]; then
                       echo "$LINE" >> $EXTRACT_SCRIPT
                    else
                       MV_DEST=$(echo "$LINE" | awk '{ print $NF}' )
                       MV_SRC=$(echo "$LINE" | awk '{ print $(NF-1)}' )
                       echo "if [ ! -L $MV_DEST ]; then if [ -d $MV_DEST ]; then if [ ! -L $MV_DEST/$EXTRACT_TAR_DIR_NOW ]; then ln -s ../$EXTRACT_TAR_DIR_NOW $MV_DEST/$EXTRACT_TAR_DIR_NOW; fi; else ln -s $EXTRACT_TAR_DIR_NOW $MV_DEST; fi; fi" >> $EXTRACT_SCRIPT
                    fi
                    ;;
                "cd "*)
                    DEST=$(echo "$LINE" | awk '{ print $NF}' )
                    case "$DEST" in
                        "/"*)
                            CURR_DIR="$DEST"
                            ;;
                        *)
                            CURR_DIR="$CURR_DIR/$DEST"
                            ;;
                    esac
                  
                    echo "$LINE" >> $EXTRACT_SCRIPT
                    ;;
                "pushd "*)
                    DEST=$(echo "$LINE" | awk '{ print $NF}' )
                    PREV_DIR="$CURR_DIR"
                    case "$DEST" in
                        "/"*)
                            CURR_DIR="$DEST"
                            ;;
                        *)
                            CURR_DIR="$CURR_DIR/$DEST"
                            ;;
                    esac
                    echo "$LINE" >> $EXTRACT_SCRIPT
                    ;;
                "popd"*)
                    CURR_DIR="$PREV_DIR"
                    echo "$LINE" >> $EXTRACT_SCRIPT
                    ;;
                "cp "*)
                    DEST=$(echo "$LINE" | awk '{ print $NF}' )
                    CPY_SRC=$(echo "$LINE" | awk '{ print $(NF-1)}' )
                    if [ "$DEST" == "linux-3.10.0.x86_64" ] && [ "$CPY_SRC" == "vanilla-3.10.0" ]; then
                       # special case for kernel-rt
                       echo "if [ ! -L "$DEST" ]; then" >> $EXTRACT_SCRIPT
                       echo "   ln -s $CPY_SRC $DEST" >> $EXTRACT_SCRIPT
                       echo "fi" >> $EXTRACT_SCRIPT
                    else
                       echo "$LINE" >> $EXTRACT_SCRIPT
                    fi
                    ;;
                "mkdir "*)
                    echo "$LINE -p" >> $EXTRACT_SCRIPT
                    ;;
                "exit "*)
                    ;;
                "grep "*)
                    ;;
                "xargs "*)
                    ;;
                "wc "*)
                    ;;
                "git init "*|\
                "git config "*|\
                "git add "*|\
                "git commit "*)
                    ;;
                *)
                    echo "$LINE" >> $EXTRACT_SCRIPT
                    ;;
            esac
            ;;
         REVERSE_TAR)
            case "$LINE" in
                "gzip -dc "*|\
                "xz -dc "*|\
                "bzip2 -dc "*|\
                "/usr/bin/gzip -dc "*|\
                "/usr/bin/xz -dc "*|\
                "/usr/bin/bzip2 -dc "*)
                    STATE="PRE_PATCH"
                    echo "$LINE | $LAST_LINE" >> $EXTRACT_SCRIPT
                    if [ $FIRST_TAR -eq 0 ]; then
                       EXTRACT_DIR=$(dirname $EXTRACT_SCRIPT)/extract_dir
                       EXTRACT_TAR_DIR=$(dirname $EXTRACT_SCRIPT)/tar_dir
                       EXTRACT_TAR_DIR_NOW=$(tar_cmd_common_dir "$LINE | tar -tvf -")
                       echo "readlink -f \$(pwd) > $EXTRACT_DIR" >> $EXTRACT_SCRIPT
                    fi
                    FIRST_TAR=1
                    ;;
                *)
                    >&2 echo "ERROR: $FUNCNAME (${LINENO}): Unexpected Line in state REVERSE_TAR: $LINE"
                    RC=1
                    break
                    ;;
            esac
            ;;
         TAR)
            case "$LINE" in
                "tar -xf -"|\
                "tar -xvf -"|\
                "tar -xvvf -"|\
                "tar -xo -f -"|\
                "/usr/bin/tar -xf -"|\
                "/usr/bin/tar -xvf -"|\
                "/usr/bin/tar -xvvf -"|\
                "/usr/bin/tar -xo -f -")
                    STATE="PRE_PATCH"
                    echo "$LAST_LINE | $LINE --exclude .git" >> $EXTRACT_SCRIPT
                    if [ $FIRST_TAR -eq 0 ]; then
                       EXTRACT_DIR=$(dirname $EXTRACT_SCRIPT)/extract_dir
                       EXTRACT_TAR_DIR=$(dirname $EXTRACT_SCRIPT)/tar_dir
                       EXTRACT_TAR_DIR_NOW=$(tar_cmd_common_dir "$LAST_LINE | tar -tvf -")
                       echo "readlink -f \$(pwd) > $EXTRACT_DIR" >> $EXTRACT_SCRIPT
                    fi
                    FIRST_TAR=1
                    ;;
                "exit "*)
                    ;;
                *)
                    >&2 echo "ERROR: $FUNCNAME (${LINENO}): Unexpected Line in state TAR: $LINE"
                    RC=1
                    break
                    ;;
            esac
            ;;
         POST_PATCH)
            if [ $POST_PATCH_FIRST_PASS -eq 0 ]; then
               POST_PATCH_FIRST_PASS=1
               PATCH_DIR=$(dirname $EXTRACT_SCRIPT)/patch_dir
               echo "readlink -f \$(pwd) > $PATCH_DIR" >> $EXTRACT_SCRIPT
               readlink -f $(pwd)
            fi
            case "$LINE" in
                "cd "*|\
                "popd"*|\
                "pushd "*)
                    echo $LINE >> $EXTRACT_SCRIPT
                    ;;
                "iconv"*)
                    local ICONV_LAST_ARG=$(echo $LINE | awk '{ print $NF }')
                    local ICONV_SECOND_LAST_ARG=$(echo $LINE | awk '{ print $(NF-1) }')
                    if [ "$ICONV_SECOND_LAST_ARG" == "utf-8" ]; then
                       # shadow-utils hack
                       echo "$LINE > $ICONV_LAST_ARG.utf8" >> $EXTRACT_SCRIPT
                    fi
                    ;;
                "cp "*)
                    DEST=$(echo "$LINE" | awk '{ print $NF}' )
                    CPY_SRC=$(echo "$LINE" | awk '{ print $(NF-1)}' )
                    if [ "$DEST" == "linux-3.10.0.x86_64" ] && [ "$CPY_SRC" == "vanilla-3.10.0" ]; then
                       # special case for kernel-rt
                       echo "if [ ! -L "$DEST" ]; then" >> $EXTRACT_SCRIPT
                       echo "   ln -s $CPY_SRC $DEST" >> $EXTRACT_SCRIPT
                       echo "fi" >> $EXTRACT_SCRIPT
                    else
                       echo "$LINE" >> $EXTRACT_SCRIPT
                    fi
                    ;;
                "mkdir "*)
                    echo "$LINE -p" >> $EXTRACT_SCRIPT
                    ;;
                "exit "*)
                    ;;
                *)
                    ;;
            esac
            ;;
      esac
      LAST_LINE="$LINE"
   done < "$RAW_SCRIPT"

   if [ $POST_PATCH_FIRST_PASS -eq 0 ]; then
      PATCH_DIR=$(dirname $EXTRACT_SCRIPT)/patch_dir
      echo "readlink -f \$(pwd) > $PATCH_DIR" >> $EXTRACT_SCRIPT
      readlink -f $(pwd)
   fi

   return $RC
}

##
## script to extract tarballs after metapatchs
## ok, not really extracting a tarball, just set up symlink if required 
##
raw_create_tarballs_extract_script_post_metapatch () {
   local RAW_SCRIPT=$1
   local EXTRACT_SCRIPT=$2
   local OLD_BUILD_DIR=$3
   local NEW_BUILD_DIR=$4

   if [ ! -f $RAW_SCRIPT ]; then
      >&2 echo "ERROR: $FUNCNAME (${LINENO}): file RAW_SCRIPT='$RAW_SCRIPT' does not exist"
      return 1
   fi

   if [ -f $EXTRACT_SCRIPT ]; then
      \rm -rf $EXTRACT_SCRIPT
   fi

   local STATE="PRE_PATCH"
   local LAST_LINE=""
   local RC=0
   local FIRST_TAR=0
   local EXTRACT_DIR=""
   local EXTRACT_TAR_DIR=""
   local EXTRACT_TAR_DIR_NOW=""
   local MV_DEST=""
   local TAR_ARGS

   echo "set -e" >> $EXTRACT_SCRIPT
   echo "set -x" >> $EXTRACT_SCRIPT

   while read -r LINE ; do
      LINE=$(echo $LINE | sed -r "s#$(echo $OLD_BUILD_DIR | sed 's#/#[/]+#g')#$NEW_BUILD_DIR#g")
      # >&2 echo "Parse: STATE=$STATE, LINE=$LINE"
      if [[ "$LINE" == "'['"* ]]; then
         # kernel-rt hack
         if [[ "$LINE" == "'[' -L vanilla-3.10.0/configs ']'" ]]; then
            echo "if [ -L vanilla-3.10.0/configs ]; then rm -f vanilla-3.10.0/configs; fi" >> $EXTRACT_SCRIPT
         fi
         # kernel hack
         if [[ "$LINE" == "'[' -L configs ']'" ]]; then
            echo "if [ -L configs ]; then rm -f configs; fi" >> $EXTRACT_SCRIPT
         fi
         continue
      fi
      case $STATE in
         PRE_PATCH)
            case "$LINE" in
                "ApplyOptionalPatch"*|\
                "ApplyPatch"*|\
                "echo 'Patch #"*)
                    STATE="POST_PATCH"
                    ;;
                "gzip -dc "*|\
                "xz -dc "*|\
                "bzip2 -dc "*|\
                "/usr/bin/gzip -dc "*|\
                "/usr/bin/xz -dc "*|\
                "/usr/bin/bzip2 -dc "*)
                    STATE="TAR"
                    ;;
                "tar -xf -"|\
                "tar -xvf -"|\
                "tar -xvvf -"|\
                "tar -xo -f -"|\
                "/usr/bin/tar -xf -"|\
                "/usr/bin/tar -xvf -"|\
                "/usr/bin/tar -xvvf -"|\
                "/usr/bin/tar -xo -f -") 
                    STATE="REVERSE_TAR"
                    ;;
                "tar -xf "*|\
                "tar -xvf "*|\
                "tar -xvvf "*|\
                "tar -xo -f "*|\
                "/usr/bin/tar -xf "*|\
                "/usr/bin/tar -xvf "*|\
                "/usr/bin/tar -xvvf "*|\
                "/usr/bin/tar -xo -f "*)
                    LINE="$LINE --exclude .git"
                    if [ $FIRST_TAR -eq 0 ]; then
                       TAR_ARGS=$(echo $LINE | sed -e 's#^/usr/bin/tar ##' -e 's#^-xf ##' -e 's#^-xvf ##' -e 's#^-xvvf ##' -e 's#^-xo -f ##')
                       EXTRACT_DIR=$(dirname $EXTRACT_SCRIPT)/extract_dir
                       EXTRACT_TAR_DIR=$(dirname $EXTRACT_SCRIPT)/tar_dir
                       EXTRACT_TAR_DIR_NOW=$(tar_cmd_common_dir "tar -tvf $TAR_ARGS")
                    fi
                    FIRST_TAR=1
                    ;;
                "git am "*)
                    STATE="POST_PATCH"
                    ;;
                "xargs git am"*)
                    STATE="POST_PATCH"
                    ;;
                "/usr/bin/patch "*|\
                "patch "*)
                    STATE="POST_PATCH"
                    ;;
                "/usr/bin/git apply "*|\
                "git apply "*)
                    STATE="POST_PATCH"
                    ;;
                "mv $EXTRACT_TAR_DIR_NOW "*)
                    if [ "x$EXTRACT_TAR_DIR_NOW" == "x" ]; then
                       echo "" >> $EXTRACT_SCRIPT
                    else
                       MV_DEST=$(echo "$LINE" | awk '{ print $NF}' )
                       MV_SRC=$(echo "$LINE" | awk '{ print $(NF-1)}' )
                       echo "if [ ! -L $MV_DEST ]; then if [ -d $MV_DEST ]; then if [ ! -L $MV_DEST/$EXTRACT_TAR_DIR_NOW ]; then ln -s ../$EXTRACT_TAR_DIR_NOW $MV_DEST/$EXTRACT_TAR_DIR_NOW; fi; else ln -s $EXTRACT_TAR_DIR_NOW $MV_DEST; fi; fi" >> $EXTRACT_SCRIPT
                    fi
                    ;;
                "cd "*|\
                "popd"*|\
                "pushd "*)
                    echo "$LINE" >> $EXTRACT_SCRIPT
                    ;;
                "mkdir "*)
                    echo "$LINE -p" >> $EXTRACT_SCRIPT
                    ;;
                "grep "*)
                    ;;
                *)
                    ;;
            esac
            ;;
         REVERSE_TAR)
            case "$LINE" in
                "gzip -dc "*|\
                "xz -dc "*|\
                "bzip2 -dc "*|\
                "/usr/bin/gzip -dc "*|\
                "/usr/bin/xz -dc "*|\
                "/usr/bin/bzip2 -dc "*)
                    STATE="PRE_PATCH"
                    if [ $FIRST_TAR -eq 0 ]; then
                       EXTRACT_DIR=$(dirname $EXTRACT_SCRIPT)/extract_dir
                       EXTRACT_TAR_DIR=$(dirname $EXTRACT_SCRIPT)/tar_dir
                       EXTRACT_TAR_DIR_NOW=$(tar_cmd_common_dir "$LINE | tar -tvf -")
                    fi
                    FIRST_TAR=1
                    ;;
                *)
                    >&2 echo "ERROR: $FUNCNAME (${LINENO}): Unexpected Line in state REVERSE_TAR: $LINE"
                    RC=1
                    break
                    ;;
            esac
            ;;
         TAR)
            case "$LINE" in
                "tar -xf -"|\
                "tar -xvf -"|\
                "tar -xvvf -"|\
                "tar -xo -f -"|\
                "/usr/bin/tar -xf -"|\
                "/usr/bin/tar -xvf -"|\
                "/usr/bin/tar -xvvf -"|\
                "/usr/bin/tar -xo -f -")
                    LINE="$LINE --exclude .git"
                    STATE="PRE_PATCH"
                    if [ $FIRST_TAR -eq 0 ]; then
                       EXTRACT_DIR=$(dirname $EXTRACT_SCRIPT)/extract_dir
                       EXTRACT_TAR_DIR=$(dirname $EXTRACT_SCRIPT)/tar_dir
                       EXTRACT_TAR_DIR_NOW=$(tar_cmd_common_dir "$LAST_LINE | tar -tvf -")
                    fi
                    FIRST_TAR=1
                    ;;
                *)
                    >&2 echo "ERROR: $FUNCNAME (${LINENO}): Unexpected Line in state TAR: $LINE"
                    RC=1
                    break
                    ;;
            esac
            ;;
         POST_PATCH)
            case "$LINE" in
                "cd "*|\
                "popd"*|\
                "pushd "*)
                    echo $LINE >> $EXTRACT_SCRIPT
                    ;;
                "mkdir "*)
                    echo "$LINE -p" >> $EXTRACT_SCRIPT
                    ;;
                *)
                    ;;
            esac
            ;;
      esac
      LAST_LINE="$LINE"
   done < "$RAW_SCRIPT"

   return $RC
}


##
## script to list patch numbers
##
raw_patch_order () {
   local RAW_SCRIPT=$1
   local SPEC_FILE=$2
   local LINE
   local LINE2
   local PATCH_NO=0

   if [ ! -f $RAW_SCRIPT ]; then
      >&2 echo "ERROR: $FUNCNAME (${LINENO}): file RAW_SCRIPT='$RAW_SCRIPT' does not exist"
      return 1
   fi


   while read -r LINE ; do
      if [[ "$LINE" == "'['"* ]]; then
         continue
      fi
      case "$LINE" in
          "echo 'Patch #"*)
              PATCH_NO=$(echo $LINE | awk '{ print $3 }' | sed 's/#//')
              echo $PATCH_NO
              ;;
          "git am "*)
              for LINE2 in $(echo $LINE | tr ' ' '\n' | grep '.patch$'); do
                 PATCH_NO=$((PATCH_NO + 1))
                 echo $PATCH_NO
              done
              ;;
          "xargs git am"*)
              grep '^Patch[0-9]*:' $SPEC_FILE |\
              while read -r LINE2; do
                 PATCH_NO=$((PATCH_NO + 1))
                 echo $PATCH_NO
              done
              ;;
          *)
              ;;
      esac
   done < "$RAW_SCRIPT"

   if [ $PATCH_NO -eq 0 ]; then
      while read -r LINE ; do
         if [[ "$LINE" == "'['"* ]]; then
            continue
         fi
         case "$LINE" in
             "cat "*|\
             "/usr/bin/cat "*)
                 PATCH_PATH=$(echo $LINE | awk '{ print $2 }')
                 PATCH_FILE=$(basename $PATCH_PATH)
                 PATCH_NO=$PATCH_FILE
                 echo $PATCH_NO
                 ;;
             *)
                 ;;
         esac
      done < "$RAW_SCRIPT"
   fi

   return 0
}

srpm_build_dictionary () {
   local srpm_dir=$1
   local srpm_path
   local name

   for srpm_path in $(find $srpm_dir -name '*.src.rpm' | sort -V); do
      name=$(rpm_get_name $srpm_path)
      SRPM_PKG_NAME_TO_PATH[$name]="$srpm_path"
      SRPM_PKG_NAMES+=("$name")
   done
}

srpm_build_std_dictionary () {
   local srpm_dir=$1
   local srpm_path
   local name

   for srpm_path in $(find $srpm_dir -name '*.src.rpm' | sort -V); do
      name=$(rpm_get_name $srpm_path)
      STD_SRPM_PKG_NAME_TO_PATH[$name]="$srpm_path"
      STD_SRPM_PKG_NAMES+=("$name")
   done
}

srpm_assemble () {
   local FULL_BUILD_DIR=$1
   local TIS_PATCH_VER=$2

   local SPEC_PATH
   local SPEC
   local SRPM_PATH
   local SRPM
   local NAME
   local VERSION
   local RELEASE
   local BUILD_NEEDED

   for SPEC in $(cd $FULL_BUILD_DIR/SPECS/; ls -1 *.spec); do
      SPEC_PATH="$FULL_BUILD_DIR/SPECS/$SPEC"
      NAME=$(srpm_spec_find_name "$SPEC_PATH" 2>> /dev/null)
      if [ $? -ne 0 ]; then
          echo "ERROR: $FUNCNAME (${LINENO}): 'Name' not found in '$SPEC_PATH'"
      fi

      VERSION=$(srpm_spec_find_version "$SPEC_PATH" 2>> /dev/null)
      if [ $? -ne 0 ]; then
          echo "ERROR: $FUNCNAME (${LINENO}): 'Version' not found in '$SPEC_PATH'"
          if [ "x$SRPM_EXPORT_NAME" != "x" ]; then
              VERSION="$SRPM_EXPORT_NAME"
          else
              VERSION="0"
          fi
      fi

      RELEASE=$(spec_find_tag Release "$SPEC_PATH" "$(dirname $(dirname $SPEC_PATH))" "$TIS_PATCH_VER" 2>> /dev/null)
      if [ $? -ne 0 ]; then
          echo "ERROR: $FUNCNAME (${LINENO}): 'Release' not found in '$SPEC_PATH'"
          RELEASE="0"
      fi

      SRPM="$NAME-$VERSION-$RELEASE.src.rpm"
      SRPM_PATH="$FULL_BUILD_DIR/SRPMS/$SRPM"

      spec_validate_tis_release $SPEC_PATH
      if [ $? -ne 0 ]; then
          echo "TIS Validation of $SPEC_PATH failed"
          exit 1
      fi

      BUILD_NEEDED=0
      if [ -f $SRPM_PATH ]; then
          n=$(find $FULL_BUILD_DIR -cnewer $SRPM_PATH | wc -l)
          if [ $n -gt 0 ]; then
              BUILD_NEEDED=1
          fi
      else
          BUILD_NEEDED=1
      fi

      if [ $BUILD_NEEDED -gt 0 ]; then
          echo "SPEC file: $SPEC_PATH"
          echo "SRPM build directory: $FULL_BUILD_DIR"
          echo "TIS_PATCH_VER: $TIS_PATCH_VER"

          sed -i -e "1 i%define _tis_build_type $BUILD_TYPE" $SPEC_PATH
          sed -i -e "1 i%define tis_patch_ver $TIS_PATCH_VER" $SPEC_PATH

          # Build the srpm as though for std build, for naming consistency
          if [ "x$PLATFORM_RELEASE" == "x" ]; then
             rpmbuild -bs $SPEC_PATH \
                 --define="%_topdir $FULL_BUILD_DIR" \
                 --define='_tis_dist .tis' \
                 --undefine=dist
          else
             rpmbuild -bs $SPEC_PATH \
                 --define="%_topdir $FULL_BUILD_DIR" \
                 --define='_tis_dist .tis' \
                 --define="platform_release $PLATFORM_RELEASE" \
                 --undefine=dist
          fi

          if [ $? -ne 0 ]; then
              echo "ERROR: $FUNCNAME (${LINENO}): rpmbuild failed: rpmbuild -bs $SPEC_PATH --define='%_topdir $FULL_BUILD_DIR' --define='_tis_dist .tis' --undefine=dist"
              return 1
          fi
      else
          echo "SRPM build not needed"
      fi
   done

   return 0
}


srpm_extract () {
   local ORIG_SRPM_PATH=$1
   local WRS_PKG_DIR=$2
   local ROOT_DIR=$3
   local BUILD_DIR=$4
   local BRANCH=$5

   local USE_GIT=0
   local ORIG_DIR=$(pwd)
   local PKG_DIR=$(rpm -q --queryformat '%{NAME}-%{VERSION}-%{RELEASE}\n' --nosignature -p $ORIG_SRPM_PATH)

   if [ "x$ROOT_DIR" == "x" ]; then
      ROOT_DIR="$MY_WORKSPACE/srpm_assemble"
   fi

   if [ "x$BUILD_DIR" == "x" ]; then
      BUILD_DIR="$PKG_DIR/rpmbuild"
   fi

   local SPEC_DIR="$ROOT_DIR/$BUILD_DIR/SPECS"
   local SOURCE_DIR="$ROOT_DIR/$BUILD_DIR/SOURCES"
   local GIT_DIR="$ROOT_DIR/$PKG_DIR/gits"
   local META_PATCH_TARGET_DIR="$ROOT_DIR/$BUILD_DIR"
   local ARCH=centos

   if [ ! -d $ROOT_DIR ]; then
      mkdir -p "$ROOT_DIR"
   fi

   if [ ! -d $SPEC_DIR ]; then
      rpm -i --nosignature --root=$ROOT_DIR --define="%_topdir $BUILD_DIR" $ORIG_SRPM_PATH 2>> /dev/null
      if [ $? -ne 0 ]; then
          echo "ERROR: $FUNCNAME (${LINENO}): Failed to extract '$ORIG_SRPM_PATH' to '$ROOT_DIR/$BUILD_DIR'"
          return 1
      fi
   fi

   for SPEC in $(cd $SPEC_DIR; ls -1 *.spec); do
      echo $SPEC;
      SPEC_GIT="$GIT_DIR/$SPEC"
      PKG_NAME=$(srpm_spec_find_name $SPEC_DIR/$SPEC 2>> /dev/null)
      PKG_VER=$(srpm_spec_find_version $SPEC_DIR/$SPEC 2>> /dev/null)
      TAR_DIR="$PKG_NAME-$PKG_VER"
      PATCH_TARGET_DIR="$SPEC_GIT/$TAR_DIR"
      echo "   $TAR_DIR"

      if [ "x$WRS_PKG_DIR" != "x" ]; then
         echo "srpm_apply_meta_patches '$META_PATCH_TARGET_DIR' '$WRS_PKG_DIR' $USE_GIT '$ARCH' '$BRANCH'"
         srpm_apply_meta_patches "$META_PATCH_TARGET_DIR" "$WRS_PKG_DIR" $USE_GIT "$ARCH" "$BRANCH"
         if [ $? -ne 0 ]; then
            cd $ORIG_DIR
            return 1
         fi
      fi
   done

   cd $ORIG_DIR
   return 0
}


srpm_apply_meta_patches () {
   local META_PATCH_TARGET_DIR=$1
   local WRS_PKG_DIR=$2
   local USE_GIT=$3
   local ARCH=$4
   local BRANCH=$5

   local ORIG_DIR=$(pwd)
   local META_PATCH_DIR
   local PATCH_DIR
   local PATCH
   local PATCH_PATH
   local PO_PATH

   echo "Applying metadata patches"
   if [ ! -d "$META_PATCH_TARGET_DIR" ]; then
      echo "ERROR: $FUNCNAME (${LINENO}): directory '$META_PATCH_TARGET_DIR' not found."
      return 1
   fi

   if [ ! -d "$WRS_PKG_DIR" ]; then
      echo "ERROR: $FUNCNAME (${LINENO}): directory '$WRS_PKG_DIR' not found."
      return 1
   fi

   META_PATCH_DIR="$WRS_PKG_DIR/$ARCH/meta_patches"
   PATCH_DIR="$WRS_PKG_DIR/$ARCH/patches"
   PO_PATH="$META_PATCH_DIR/PATCH_ORDER"
   if [ ! -f $PO_PATH ]; then
      echo "No WRS patches to apply"
      return 0
   fi

   cd $META_PATCH_TARGET_DIR
   if [ $? -ne 0 ]; then
      echo "ERROR: $FUNCNAME (${LINENO}): failed to change directory to '$META_PATCH_TARGET_DIR'"
      return 1
   fi

   for PATCH in $(cat $PO_PATH); do
      PATCH_PATH="$META_PATCH_DIR/$PATCH"
      if [ ! -f "$PATCH_PATH" ]; then
         echo "ERROR: $FUNCNAME (${LINENO}): patch '$PATCH_PATH' not found."
         cd $ORIG_DIR
         return 1
      fi

      echo "srpm_apply_patch '$PATCH_PATH' '-p1' '$META_PATCH_TARGET_DIR' $USE_GIT 'WRS: ' '$METHOD_NO_RPMBUILD' '' '' '' '' 0 '$BRANCH' ''"
      srpm_apply_patch "$PATCH_PATH" "-p1" "$META_PATCH_TARGET_DIR" $USE_GIT "WRS: " $METHOD_NO_RPMBUILD "" "" "" "" 0 "$BRANCH" "" 0

      if [ $? -ne 0 ]; then
         echo "ERROR: $FUNCNAME (${LINENO}): failed to apply patch '$PATCH'"
         cd $ORIG_DIR
         return 1
      fi
   done

   local d
   local dd
   local f
   local ff

   if [ -d "$PATCH_DIR" ]; then
      echo ".gitignore" >> "$META_PATCH_TARGET_DIR/.gitignore"
      cd $PATCH_DIR

      if [ $? -ne 0 ]; then
         echo "ERROR: Failed to cd to '$PATCH_DIR'"
         cd $ORIG_DIR
         return 1
      fi

      for dd in $(find . -type d | sort -V); do
         d=${dd:2}
         mkdir -p "$META_PATCH_TARGET_DIR/SOURCES/$d"
         if [ $? -ne 0 ]; then
            echo "ERROR: Failed to mkdir '$META_PATCH_TARGET_DIR/SOURCES/$d'"
            cd $ORIG_DIR
            return 1
         fi
      done

      for ff in $(find . -type f | sort -V); do
         f=${ff:2}
         d=$(dirname $f)
         \cp -L -f -v "$PATCH_DIR/$f" "$META_PATCH_TARGET_DIR/SOURCES/$d"
         if [ $? -ne 0 ]; then
            echo "ERROR: Failed to copy '$PATCH_DIR/$f' to '$META_PATCH_TARGET_DIR/SOURCES/$d'"
            cd $ORIG_DIR
            return 1
         fi
         echo "SOURCES/$f" >> "$META_PATCH_TARGET_DIR/.gitignore"
      done
   fi

   cd $ORIG_DIR
   return 0
}

export GLOBAL_PATCH_TARGET_DIR=""


commit_git () {
   local DIR="$1"
   local COMMIT_MESSAGE="$2"
   local TAG="$3"

   local ORIG_DIR=$(pwd)

   # Add and Commit
   cd $DIR
   echo "git add .  @  $(pwd)"
   git add .
   if [ $? -ne 0 ]; then
      echo "ERROR: $FUNCNAME (${LINENO}): 'git add' failed for at '$DIR'"
      cd $ORIG_DIR
      return 1
   fi

   echo "git commit --allow-empty -m '$COMMIT_MESSAGE'  @  $(pwd)"
   git commit --allow-empty -m "$COMMIT_MESSAGE"
   if [ $? -ne 0 ]; then
      echo "ERROR: $FUNCNAME (${LINENO}): 'git commit' failed at '$DIR'"
      cd $ORIG_DIR
      return 1
   fi

   # Tag the contents
   if [ "$TAG" != "" ]; then
      echo "git tag $TAG  @  $(pwd)"
      git tag $TAG
      if [ $? -ne 0 ]; then
         echo "ERROR: $FUNCNAME (${LINENO}): 'git tag' failed at '$DIR'"
         cd $ORIG_DIR
         return 1
      fi
   fi

   cd $ORIG_DIR >> /dev/null
   return 0
}

init_git_if_required () {
   local DIR="$1"
   local COMMIT_MESSAGE="$2"
   local TAG="$3"

   local ORIG_DIR=$(pwd)

   cd $DIR

   # Initialize git if this is our first time
   if [ ! -d .git ]; then
      echo "$(pwd)/.git  not found, creating a new git"
      echo "git init  @  $(pwd)"
      git init
      if [ $? -ne 0 ]; then
         echo "ERROR: $FUNCNAME (${LINENO}): 'git init' failed for at '$BUILD_DIR'"
         cd $ORIG_DIR
         return 1
      fi

      echo "git add .  @  $(pwd)"
      git add .
      if [ $? -ne 0 ]; then
         echo "ERROR: $FUNCNAME (${LINENO}): 'git add' failed for at '$DIR'"
         cd $ORIG_DIR
         return 1
      fi

      echo "git commit --allow-empty -m '$COMMIT_MESSAGE'  @  $(pwd)"
      git commit --allow-empty -m "$COMMIT_MESSAGE"
      if [ $? -ne 0 ]; then
         echo "ERROR: $FUNCNAME (${LINENO}): 'git commit' failed at '$DIR'"
         cd $ORIG_DIR
         return 1
      fi

      # Tag the contents
      if [ "$TAG" != "" ]; then
         echo "git tag $TAG  @  $(pwd)"
         git tag $TAG
         if [ $? -ne 0 ]; then
            echo "ERROR: $FUNCNAME (${LINENO}): 'git tag' failed at '$DIR'"
            cd $ORIG_DIR
            return 1
         fi
      fi
   fi

   cd $ORIG_DIR >> /dev/null
   return 0
}

prep_git_for_metadata () {
   local BUILD_DIR="$1"
   local BRANCH="$2"
   local NO_META_PATCH="$3"
   local PRE_WRS_PREFIX="$4"

   local ORIG_BRANCH=""
   local ORIG_PRE_WRS_TAG=""
   local ORIG_DIR=$(pwd)

   cd $BUILD_DIR

   # Initialize git if this is our first time
   init_git_if_required "." "ORIGINAL: initial commit" ""
   if [ $? -ne 0 ]; then
      echo "ERROR: $FUNCNAME (${LINENO}): init_git_if_required failed for at '$(pwd)'"
      cd $ORIG_DIR
      return 1
   fi

   if [ "x$NO_META_PATCH" == "x1" ]; then
      ORIG_BRANCH=$(git rev-parse --abbrev-ref HEAD)
      ORIG_PRE_WRS_TAG="$PRE_WRS_PREFIX$ORIG_BRANCH"
   fi

   # Delete branch if it previously existed
   git checkout $BRANCH &>> /dev/null
   if [ $? -eq 0 ]; then
       git checkout master
       git branch -D $BRANCH
       if [ $? -ne 0 ]; then
          echo "ERROR: $FUNCNAME (${LINENO}): failed to delete branch '$BRANCH' at '$(pwd)'"
          cd $ORIG_DIR
          return 1
       fi
   fi

   # create branch
   if [ "x$ORIG_PRE_WRS_TAG" != "x" ]; then
      git checkout $ORIG_PRE_WRS_TAG
      if [ $? -ne 0 ]; then
         git checkout master
      fi
   else
      git checkout master
   fi

   echo "git checkout -b $BRANCH"
   git checkout -b $BRANCH
   if [ $? -ne 0 ]; then
      echo "ERROR: $FUNCNAME (${LINENO}): failed to create branch '$BRANCH' at '$(pwd)'"
      cd $ORIG_DIR
      return 1
   fi

   cd $ORIG_DIR >> /dev/null
   return 0
}

   
tarball_extract () {
   local SPEC_DIR="${1}"
   local SPEC="${2}"
   local SPEC_GIT="${3}"
   local SOURCE_DIR="${4}"
   local BRANCH="${5}"
   local ORIG_BRANCH="${6}"
   local TAR_DIR="${7}"
   local ROOT_DIR="${8}"
   local PKG_DIR="${9}"
   local BUILD_DIR="${10}"
   local TARGET_ARCH="${11}"
   local TIS_PATCH_VER="${12}"
   local OUTPUT_FILE="${13}"
   local NO_META_PATCH=${14}
   # BUILD_TYPE exported from higher layers 

   echo "tarball_extract  SPEC_DIR=$SPEC_DIR  SPEC=$SPEC  SPEC_GIT=$SPEC_GIT  SOURCE_DIR=$SOURCE_DIR  BRANCH=$BRANCH  ORIG_BRANCH=$ORIG_BRANCH  TAR_DIR=$TAR_DIR  ROOT_DIR=$ROOT_DIR  PKG_DIR=$PKG_DIR  BUILD_DIR=$BUILD_DIR  TARGET_ARCH=$TARGET_ARCH  TIS_PATCH_VER=$TIS_PATCH_VER  OUTPUT_FILE=$OUTPUT_FILE  NO_META_PATCH=$NO_META_PATCH"

   if [ -f $OUTPUT_FILE ]; then
      \rm -f $OUTPUT_FILE
   fi

   local ALT_TAR_DIR=""
   local SOURCE_NO=""
   local SOURCE_NAME=""
   local TAR=""
   local TAR_HAS_CHANGED=1
   local REAL_TYPE=""
   local ORIG_DIR="$(pwd)"
   local TAR_EXTRACT_ARG=""
   local PATCH_TARGET_DIR=""
   local EXTRACT_TO_DIR=""
   local AUTOSETUP_MACRO=""
   local AUTOSETUP=0
   local METHOD=$METHOD_RPMBUILD_SCRIPT
   local RPMBUILD_BP_LOG=$ROOT_DIR/$PKG_DIR/rpmbuild_bp.log
   local RPMBUILD_BUILD_DIR=$ROOT_DIR/$BUILD_DIR/BUILD
   local EXCLUDE_PATCH_NUM_CSV=""
   local RAW_SCRIPT=""
   local EXTRACT_SCRIPT=""


   # Create a directory for the extraction of tarballs
   echo "SPEC_GIT=$SPEC_GIT"
   echo "mkdir -p  $SPEC_GIT"
   mkdir -p  $SPEC_GIT
   echo "cd $SPEC_GIT"
   cd $SPEC_GIT
   pwd

   # Extract tarballs named in spec file

   # Does this spec file use autosetup
   AUTOSETUP_MACRO=$(grep '%autosetup' $SPEC_DIR/$SPEC)
   if [ $? -eq 0 ]; then
      AUTOSETUP=1
   fi

   if [ $METHOD -eq $METHOD_RPMBUILD_SCRIPT ]; then
       if [ -d "$RPMBUILD_BUILD_DIR" ]; then
           echo "rm -rf RPMBUILD_BUILD_DIR=$RPMBUILD_BUILD_DIR"
           \rm -rf "$RPMBUILD_BUILD_DIR"
       fi
       mkdir -p $RPMBUILD_BUILD_DIR

       if [ -f $RPMBUILD_BP_LOG ]; then
          echo "rm -f RPMBUILD_BP_LOG=$RPMBUILD_BP_LOG"
          \rm -f $RPMBUILD_BP_LOG
       fi
       touch $RPMBUILD_BP_LOG

       RAW_SCRIPT=$ROOT_DIR/$PKG_DIR/raw_script
       EXTRACT_SCRIPT=$ROOT_DIR/$PKG_DIR/extract_script
       echo "srpm_create_raw_extract_script '$SPEC_DIR/$SPEC' '$ROOT_DIR/$PKG_DIR'  '$ROOT_DIR/$BUILD_DIR'  '$TARGET_ARCH' '$TIS_PATCH_VER' '$RAW_SCRIPT' '$TAR_DIR'"
       srpm_create_raw_extract_script "$SPEC_DIR/$SPEC" "$ROOT_DIR/$PKG_DIR" "$ROOT_DIR/$BUILD_DIR"  "$TARGET_ARCH" "$TIS_PATCH_VER" "$RAW_SCRIPT" "$TAR_DIR"
       if [ $? -ne 0 ]; then
           echo "ERROR: $FUNCNAME (${LINENO}): srpm_create_raw_extract_script failed"
           cd $ORIG_DIR
           return 1
       fi

       if [ -d "$RPMBUILD_BUILD_DIR" ]; then
           echo "rm -rf RPMBUILD_BUILD_DIR=$RPMBUILD_BUILD_DIR"
           \rm -rf "$RPMBUILD_BUILD_DIR"
       fi
       mkdir -p $RPMBUILD_BUILD_DIR

       echo "raw_create_tarballs_extract_script '$RAW_SCRIPT'  '$EXTRACT_SCRIPT'  '$RPMBUILD_BUILD_DIR'  '$SPEC_GIT'"
       EXTRACT_TO_DIR=$(raw_create_tarballs_extract_script "$RAW_SCRIPT"  "$EXTRACT_SCRIPT"  "$RPMBUILD_BUILD_DIR"  "$SPEC_GIT")
       if [ $? -ne 0 ]; then
           echo "ERROR: $FUNCNAME (${LINENO}): srpm_create_raw_extract_script failed"
           cd $ORIG_DIR
           return 1
       fi
       echo "EXTRACT_TO_DIR=$EXTRACT_TO_DIR"
   fi

   local EXTRACT_DIR_FILE=""
   local EXTRACT_TARGET_DIR=""
   local OLD_EXTRACT_TARGET_DIR=""
   local SAVE_OLD_EXTRACT_TARGET_DIR=""
   local PATCH_DIR_FILE=""
   local PATCH_TARGET_DIR=""
   local OLD_PATCH_TARGET_DIR=""
   local SAVE_OLD_PATCH_TARGET_DIR=""

   if [ $METHOD -eq $METHOD_RPMBUILD_SCRIPT ]; then
      EXTRACT_DIR_FILE=$(dirname $EXTRACT_SCRIPT)/extract_dir
      PATCH_DIR_FILE=$(dirname $EXTRACT_SCRIPT)/patch_dir
      if [ -f $EXTRACT_DIR_FILE ]; then
         OLD_EXTRACT_TARGET_DIR=$(cat $EXTRACT_DIR_FILE)
      fi
      if [ -f $PATCH_DIR_FILE ]; then
         OLD_PATCH_TARGET_DIR=$(cat $PATCH_DIR_FILE)
      fi
      if [ "$OLD_PATCH_TARGET_DIR" != "" ] && [ -d $OLD_PATCH_TARGET_DIR ]; then
         SAVE_OLD_PATCH_TARGET_DIR="${OLD_PATCH_TARGET_DIR}.save"
         echo "mv $OLD_PATCH_TARGET_DIR $SAVE_OLD_PATCH_TARGET_DIR"
         mv $OLD_PATCH_TARGET_DIR $SAVE_OLD_PATCH_TARGET_DIR
      fi
      if [ "$OLD_EXTRACT_TARGET_DIR" != "" ] && [ -d $OLD_EXTRACT_TARGET_DIR ]; then
         SAVE_OLD_EXTRACT_TARGET_DIR="${OLD_EXTRACT_TARGET_DIR}.save"
         echo "mv $OLD_EXTRACT_TARGET_DIR $SAVE_OLD_EXTRACT_TARGET_DIR"
         mv $OLD_EXTRACT_TARGET_DIR $SAVE_OLD_EXTRACT_TARGET_DIR
      fi
      if [ ! -d $SPEC_GIT ]; then
         mkdir -p $SPEC_GIT
      fi
      (
       source $EXTRACT_SCRIPT
       RC=$?
       echo "SRPM_EXTRACT_DIR=$(pwd)"
       exit $RC
      ) | tee $EXTRACT_SCRIPT.pre.log
      if [ ${PIPESTATUS[0]} -ne 0 ] ; then
         echo "ERROR: Failed in script '$EXTRACT_SCRIPT'"
         cd $ORIG_DIR
         return 1
      fi

      CANONICAL_SPEC_GIT=$(readlink -f "$SPEC_GIT")
      EXTRACT_TARGET_DIR=$(cat $EXTRACT_DIR_FILE)
      PATCH_TARGET_DIR=$(cat $PATCH_DIR_FILE)
      TAR_DIR=$(echo "$PATCH_TARGET_DIR" | sed "s#^$CANONICAL_SPEC_GIT/##" | sed "s#^$CANONICAL_SPEC_GIT##")
      if [ "$TAR_DIR" == "" ]; then
         TAR_DIR="."
      fi
      echo "=== CANONICAL_SPEC_GIT=$CANONICAL_SPEC_GIT"
      echo "=== TAR_DIR=$TAR_DIR"
      echo "=== PATCH_TARGET_DIR=$PATCH_TARGET_DIR"
      echo "=== EXTRACT_TARGET_DIR=$EXTRACT_TARGET_DIR"
      if [ "$PATCH_TARGET_DIR" == "$TAR_DIR" ] || [ "$PATCH_TARGET_DIR" == "" ] || [ "$EXTRACT_TARGET_DIR" == "" ] || [[ "$TAR_DIR" == /* ]]; then
         echo "Something went wrong"
         cd $ORIG_DIR
         return 1
      fi
      
      echo "rm -rf $PATCH_TARGET_DIR; mkdir -p  $PATCH_TARGET_DIR"
      \rm -rf "$PATCH_TARGET_DIR"
      mkdir -p "$PATCH_TARGET_DIR"

      if [ "$SAVE_OLD_EXTRACT_TARGET_DIR" != "" ] && [ -d $SAVE_OLD_EXTRACT_TARGET_DIR ]; then
         echo "mv $SAVE_OLD_EXTRACT_TARGET_DIR $OLD_EXTRACT_TARGET_DIR"
         if [ -d $OLD_EXTRACT_TARGET_DIR ]; then
            \rm -rf $OLD_EXTRACT_TARGET_DIR
         fi
         mv $SAVE_OLD_EXTRACT_TARGET_DIR $OLD_EXTRACT_TARGET_DIR
      fi
      if [ "$SAVE_OLD_PATCH_TARGET_DIR" != "" ] && [ -d $SAVE_OLD_PATCH_TARGET_DIR ]; then
         echo "mv $SAVE_OLD_PATCH_TARGET_DIR $OLD_PATCH_TARGET_DIR"
         if [ -d $OLD_PATCH_TARGET_DIR ]; then
            \rm -rf $OLD_EXTRACT_TARGET_DIR
         fi
         mv $SAVE_OLD_PATCH_TARGET_DIR $OLD_PATCH_TARGET_DIR
      fi
   else
      # Figure out where tarball will extract to... 
      # afterwards  ALT_TAR_DIR = common path element found in all files in the tarball
      for SOURCE_NO in $(grep -i '^Source[0-9]*:' $SPEC_DIR/$SPEC | awk -F : '{print $1}' | sort  --unique --version-sort); do
         echo "   $SOURCE_NO"
         SOURCE_NAME=$(spec_find_tag $SOURCE_NO $SPEC_DIR/$SPEC 2>> /dev/null | awk -F / '{print $NF}')
         if [ "x$SOURCE_NAME" != "x" ]; then
            echo "      $SOURCE_NAME"
            TAR="$SOURCE_DIR/$SOURCE_NAME"
            echo "         TAR=$TAR"
            # Where will the tarball install to ... put it in ALT_TAR_DIR
            if [ -f $TAR ]; then
               if [ "$ALT_TAR_DIR" == "" ]; then
                  if [ "x$ORIG_BRANCH" == "x" ]; then
                     TAR_HAS_CHANGED=1
                  else
                     cd $SOURCE_DIR
                     TAR_HAS_CHANGED=$(git diff $BRANCH $ORIG_BRANCH --name-only -- $SOURCE_NAME | wc -l)
                     cd - >> /dev/null
                  fi
      
                  echo "         TAR_HAS_CHANGED=$TAR_HAS_CHANGED"
      
                  case $SOURCE_NAME in
                     *.tar.gz)  REAL_TYPE=$(file $TAR | awk -F : '{ print $2 }')   
                                # For whatever reason, centos-release-7-2.1511.tar.gz is actually
                                # an uncompressed tarball, regardless of the name
                                if [ "$REAL_TYPE" == " POSIX tar archive (GNU)" ];  then
                                   ALT_TAR_DIR=$(tar_cmd_common_dir "tar -tvf $TAR")
                                else
                                   ALT_TAR_DIR=$(tar_cmd_common_dir "tar -tzvf $TAR")
                                fi
                                ;;
                     *.tgz)     ALT_TAR_DIR=$(tar_cmd_common_dir "tar -tzvf $TAR") ;;
                     *.tar.bz2) ALT_TAR_DIR=$(tar_cmd_common_dir "tar -tjvf $TAR") ;;
                     *.tar.xz)  ALT_TAR_DIR=$(tar_cmd_common_dir "tar -tJvf $TAR") ;;
                     *.tar)     ALT_TAR_DIR=$(tar_cmd_common_dir "tar -tvf $TAR") ;;
                     *)         echo "skipping '$SOURCE_NAME'";;
                  esac
                  echo "         ALT_TAR_DIR=$ALT_TAR_DIR"
               fi
            else
               echo "ERROR: $FUNCNAME (${LINENO}): '$SOURCE_NAME' not found in '$SOURCE_DIR'"
               cd $ORIG_DIR
               return 1
            fi
         else
            echo "WARNING: nothing found by 'spec_find_tag $SOURCE_NO $SPEC_DIR/$SPEC'"
         fi
      done

      echo "TAR_DIR=$TAR_DIR"
      echo "ALT_TAR_DIR=$ALT_TAR_DIR"

      if [ "$ALT_TAR_DIR" == "." ]; then
         TAR_EXTRACT_ARG=" -C $TAR_DIR"
      elif [ "$ALT_TAR_DIR" != "." ] && [ "$ALT_TAR_DIR" != "" ]; then
         if [ $AUTOSETUP -eq 0 ]; then
            TAR_DIR="$ALT_TAR_DIR"
         else
            TAR_DIR="$TAR_DIR/$ALT_TAR_DIR"
         fi
      fi

      PATCH_TARGET_DIR="$SPEC_GIT/$TAR_DIR"
   fi

   export GLOBAL_PATCH_TARGET_DIR="$PATCH_TARGET_DIR"
   echo "TAR_DIR=$TAR_DIR"
   echo "PATCH_TARGET_DIR=$PATCH_TARGET_DIR"

   if [ -z "$TAR_DIR" ]; then
       echo "No tarball found."
       return 1
   fi

   if [ "x$NO_META_PATCH" == "x1" ] && [ -d "$TAR_DIR" ] && [ $(ls -1 "$TAR_DIR" | wc -l) -gt 0 ]; then
      echo "Tarball already extracted, and we are processing an upgrade. Skipping tarball extract"
      echo "PATCH_TARGET_DIR=$PATCH_TARGET_DIR" > $OUTPUT_FILE
      echo "EXCLUDE_PATCH_NUM_CSV=$EXCLUDE_PATCH_NUM_CSV" >> $OUTPUT_FILE
      echo "METHOD=$METHOD" >> $OUTPUT_FILE
      echo "RAW_SCRIPT=$RAW_SCRIPT" >> $OUTPUT_FILE
      echo "RPMBUILD_BUILD_DIR=$RPMBUILD_BUILD_DIR" >> $OUTPUT_FILE
      return 0
   fi

   if [ ! -d "$TAR_DIR" ]; then
      mkdir -p $TAR_DIR
   fi

   if [ -d "$TAR_DIR" ]; then
      cd $TAR_DIR

      (init_git_if_required "." "ORIGINAL: initial commit" "")
      if [ $? -ne 0 ]; then
         echo "ERROR: $FUNCNAME (${LINENO}): init_git_if_required failed at '$(pwd)' while extracting '$SPEC_PATH'"
         cd $ORIG_DIR
         return 1
      fi

      echo "git created at '$(pwd)'"
      cd - >> /dev/null
   fi

   local NEED_TAR_EXTRACT=1

   # Set up Branch
   if [ -d "$TAR_DIR" ]; then
      echo "cd '$TAR_DIR'"
      cd $TAR_DIR
      pwd

      # Delete old branch if it exists
      echo "git checkout $BRANCH  @  $(pwd)"
      git checkout $BRANCH &>> /dev/null
      if [ $? -eq 0 ]; then
          echo "git checkout master  @  $(pwd)"
          git checkout master
          echo "git branch -D $BRANCH  @  $(pwd)"
          git branch -D $BRANCH
          if [ $? -ne 0 ]; then
             echo "ERROR: $FUNCNAME (${LINENO}): failed to delete branch '$BRANCH'"
             cd $ORIG_DIR
             return 1
          fi
      fi

      # Determine origin of our branch
      if [ $TAR_HAS_CHANGED -gt 0 ]; then
         echo "git checkout master  @  $(pwd)"
         git checkout master
      else
         echo "git checkout $ORIG_PRE_WRS_TAG  @  $(pwd)"
         git checkout $ORIG_PRE_WRS_TAG
         if [ $? -eq 0 ]; then
            NEED_TAR_EXTRACT=0
         else
            git checkout master
         fi
      fi

      cd - >> /dev/null
   fi

   # Extract tarball(s) if needed
   echo "NEED_TAR_EXTRACT=$NEED_TAR_EXTRACT"
   if [ $NEED_TAR_EXTRACT -eq 1 ]; then

       # Create branch
       echo "cd $TAR_DIR; git checkout -b $BRANCH"
       cd $TAR_DIR
       git checkout -b $BRANCH
       if [ $? -ne 0 ]; then
          echo "ERROR: $FUNCNAME (${LINENO}): failed to create branch '$BRANCH'"
          cd $ORIG_DIR
          return 1
       fi
       cd - >> /dev/null

       #########################################################################
       if [ $METHOD -eq $METHOD_NO_RPMBUILD ]; then
           # Don't use rpmbuild to extrace tarball, instead try to do it for ourselves
           for SOURCE_NO in $(grep -i '^Source[0-9]*:' $SPEC_DIR/$SPEC | awk -F : '{print $1}'); do
              echo "   $SOURCE_NO"
              local NO=$(echo $SOURCE_NO | sed 's/Source//')
              SOURCE_NAME=$(spec_find_tag $SOURCE_NO $SPEC_DIR/$SPEC 2>> /dev/null | awk -F / '{print $NF}')
              echo "      $SOURCE_NAME"
              TAR="$SOURCE_DIR/$SOURCE_NAME"
              echo "         $TAR"
              if [ -f $TAR ]; then
                 if [ $NEED_TAR_EXTRACT -eq 1 ]; then
                    echo "spec_untar_path '$NO' '$SPEC_DIR/$SPEC'"
                    local UNTAR_PATH=$(spec_untar_path "$NO" "$SPEC_DIR/$SPEC")
                    echo "UNTAR_PATH=$UNTAR_PATH"
                    mkdir -p $UNTAR_PATH
                    if [ $? -ne 0 ]; then
                        echo "ERROR: $FUNCNAME (${LINENO}): command failed: mkdir -p $UNTAR_PATH"
                        cd $ORIG_DIR
                        return 1
                    fi
                    (
                    cd $UNTAR_PATH
                    case $SOURCE_NAME in
                       *.tar.gz)  REAL_TYPE=$(file $TAR | awk -F : '{ print $2 }')
                          # For whatever reason, centos-release-7-2.1511.tar.gz is actually
                          # an uncompressed tarball, regardless of the name
                          if [ "$REAL_TYPE" == " POSIX tar archive (GNU)" ];  then
                             tar_cmd_common_dir "tar -xvf $TAR $TAR_EXTRACT_ARG"
                          else
                             tar_cmd_common_dir "tar -xzvf $TAR $TAR_EXTRACT_ARG"
                          fi
                          ;;
                       *.tgz)     tar -xzvf $TAR $TAR_EXTRACT_ARG ;;
                       *.tar.bz2) tar -xjvf $TAR $TAR_EXTRACT_ARG ;;
                       *.tar.xz)  tar -xJvf $TAR $TAR_EXTRACT_ARG ;;
                       *.tar)     tar -xvf $TAR $TAR_EXTRACT_ARG ;;
                       *) echo "skipping '$SOURCE_NAME'";;
                    esac
                    exit $?
                    )
                    if [ $? -ne 0 ]; then
                        echo "ERROR: $FUNCNAME (${LINENO}): tar failed to extract '$TAR'"
                        cd $ORIG_DIR
                        return 1
                    fi
                 fi
              else
                 echo "ERROR: $FUNCNAME (${LINENO}): '$SOURCE_NAME' not found in '$SOURCE_DIR'"
                 cd $ORIG_DIR
                 return 1
              fi
           done
       fi

       #########################################################################
       if [ $METHOD -eq $METHOD_RPMBUILD_UNPATCH ]; then
           if [ -d "$RPMBUILD_BUILD_DIR" ]; then
               \rm -rf "$RPMBUILD_BUILD_DIR"
           fi
           mkdir -p $RPMBUILD_BUILD_DIR

           # The following rpmbuild will extract all tarballs, run any other prep script, and apply all patches

           local NEED_PATCH_ROLLBACK=0
           local LAST_PATCH=$(grep '^%patch[0-9]' $SPEC_DIR/$SPEC | tail -n 1 | awk '{ print $1 }')
           if [ "x$LAST_PATCH" == "x" ]; then
               cat $SPEC_DIR/$SPEC | grep -v '^git ' > $SPEC_DIR/_$SPEC
           else
               cat $SPEC_DIR/$SPEC | grep -v '^git ' | grep -v '^%build' | sed "/$LAST_PATCH/a %build" > $SPEC_DIR/_$SPEC
               NEED_PATCH_ROLLBACK=1
           fi

           if [ -f $RPMBUILD_BP_LOG ]; then
              \rm -f $RPMBUILD_BP_LOG
           fi
           touch $RPMBUILD_BP_LOG
           # Note stdout and stderr go to same file,  must not use 2>&1 syntax as it doesn't guarantee order
           # Build the srpm as though for std build, for naming consistency
           echo "rpmbuild -bp $SPEC_DIR/_$SPEC --root $ROOT_DIR/$PKG_DIR --define='%_topdir $ROOT_DIR/$BUILD_DIR' --define='_tis_dist .tis' --nodeps --target $TARGET_ARCH >> $RPMBUILD_BP_LOG 2>> $RPMBUILD_BP_LOG"
           rpmbuild -bp $SPEC_DIR/_$SPEC --root $ROOT_DIR/$PKG_DIR \
               --define="%_topdir $ROOT_DIR/$BUILD_DIR" \
               --define='_tis_dist .tis' \
               --define="_tis_build_type $BUILD_TYPE" \
               --nodeps --target $TARGET_ARCH >> $RPMBUILD_BP_LOG 2>> $RPMBUILD_BP_LOG
           if [ $? -ne 0 ]; then
               echo "ERROR: $FUNCNAME (${LINENO}): command failed: rpmbuild -bp $SPEC_DIR/$SPEC --root $ROOT_DIR/$PKG_DIR --define='%_topdir $ROOT_DIR/$BUILD_DIR' --define='_tis_dist .tis' --nodeps --target $TARGET_ARCH > $RPMBUILD_BP_LOG"
               cd $ORIG_DIR
               return 1
           fi

           \rm -f $SPEC_DIR/_$SPEC

           if [ $NEED_PATCH_ROLLBACK -eq 1 ]; then
              # But we don't want patches yet, so roll them back.
              # Use the log from rpmbuild to learn what patches to roll back, in what order, and with what arguements
              for n in $(grep '^[Pp]atch #' $RPMBUILD_BP_LOG | tac | awk '{ print $2 }' | sed 's/#//'); do
                 cmd1=$(cat $RPMBUILD_BP_LOG | sed -n "/^[Pp]atch #$n /,/^patching/p" | grep '^+' | sed 's/^+ //' | grep '[/]cat')
                 cmd2=$(cat $RPMBUILD_BP_LOG | sed -n "/^[Pp]atch #$n /,/^patching/p" | grep '^+' | sed 's/^+ //' | grep '[/]patch')
                 cmd="$cmd1 | $cmd2 -R"
                 (
                    echo "Remove patch #$n"
                    cd $RPMBUILD_BUILD_DIR/$TAR_DIR
                    echo "$cmd"
                    eval $cmd
                    if [ ${PIPESTATUS[0]} -ne 0 ] ; then
                       echo "ERROR: $FUNCNAME (${LINENO}): failed command: $cmd"
                       return 1
                    fi
                 )
                 if [ $? -ne 0 ]; then
                    return 1
                 fi
              done
           fi

           echo "find $RPMBUILD_BUILD_DIR/$TAR_DIR/ -mindepth 1 -maxdepth 1 -exec mv -t $SPEC_GIT/$TAR_DIR/ -- {} +"
           find $RPMBUILD_BUILD_DIR/$TAR_DIR/ -mindepth 1 -maxdepth 1 -exec mv -t $SPEC_GIT/$TAR_DIR/ -- {} +

           \rm -rf "$RPMBUILD_BUILD_DIR"

           grep '^%patch[0-9]* ' $SPEC_DIR/$SPEC > /dev/null
           if [ $? -eq 0 ];then
              echo "Using '%patch' method"

             local PATCH_NO=""
              # for PATCH_NO in $(grep '^%patch[0-9]* ' $SPEC_DIR/$SPEC | awk  '{print $1}' | sed 's/^%patch//') ; do
              for PATCH_NO in $(grep -i '^[Pp]atch[0-9]*:' "$SPEC_DIR/$SPEC" | awk -F : '{print $1}' | sed 's/^[Pp]atch//' | sort  --unique --version-sort); do
                 grep "^[Pp]atch #$PATCH_NO " $RPMBUILD_BP_LOG
                 if [ $? -ne 0 ]; then
                    if [ "x$EXCLUDE_PATCH_NUM_CSV" == "x" ]; then
                       EXCLUDE_PATCH_NUM_CSV="$PATCH_NO"
                    else
                       EXCLUDE_PATCH_NUM_CSV="$EXCLUDE_PATCH_NUM_CSV,$PATCH_NO"
                    fi
                 fi
              done
           else
              grep '^git am' $SPEC_DIR/$SPEC > /dev/null
              if [ $? -eq 0 ];then
                 echo "Using 'git am' method, EXCLUDE_PATCH_NUM_CSV=''"
              else
                 echo "Warning: no known patch apply command, EXCLUDE_PATCH_NUM_CSV=''"
              fi
           fi
       fi

       #########################################################################
       if [ $METHOD -eq $METHOD_RPMBUILD_SCRIPT ]; then
           (
            # SAL
            source $EXTRACT_SCRIPT
            RC=$?
            echo "SRPM_EXTRACT_DIR=$(pwd)"
            exit $RC
           ) | tee $EXTRACT_SCRIPT.log
           if [ ${PIPESTATUS[0]} -ne 0 ] ; then
              echo "ERROR: Failed in script '$EXTRACT_SCRIPT'"
              cd $ORIG_DIR
              return 1
           fi

           local TMP_PATCH_TARGET_DIR=$(cat $PATCH_DIR_FILE)
           if [ "x$TMP_PATCH_TARGET_DIR" != "x" ]; then
              export GLOBAL_PATCH_TARGET_DIR=$TMP_PATCH_TARGET_DIR
              echo "EXTRACT_TO_DIR=$EXTRACT_TO_DIR"
              echo "GLOBAL_PATCH_TARGET_DIR=$GLOBAL_PATCH_TARGET_DIR"
              EXTRACT_TO_DIR="$GLOBAL_PATCH_TARGET_DIR"
           fi

           if [ -z "$EXTRACT_TO_DIR" ]; then
               echo "Failed to get EXTRACT_TO_DIR from raw_create_tarballs_extract_script"
               cd $ORIG_DIR
               return 1
           fi

           if [ "$EXTRACT_TO_DIR" != "$PATCH_TARGET_DIR" ]; then
               echo "Change PATCH_TARGET_DIR from '$PATCH_TARGET_DIR' to '$EXTRACT_TO_DIR'"
               PATCH_TARGET_DIR="$EXTRACT_TO_DIR"
               export GLOBAL_PATCH_TARGET_DIR="$PATCH_TARGET_DIR"
           fi

           echo "rm -rf $RPMBUILD_BUILD_DIR"
           \rm -rf "$RPMBUILD_BUILD_DIR"


       fi
   fi

   echo "aaa TAR_DIR=$TAR_DIR"
   if [ ! -d "$TAR_DIR" ]; then
      echo "ERROR: $FUNCNAME (${LINENO}): Failed to create expected TAR_DIR='$TAR_DIR' from $(pwd)"
      cd $ORIG_DIR
      return 1
   fi

   # track extracted tarball in git
   cd "$TAR_DIR"
   echo "NEED_TAR_EXTRACT=$NEED_TAR_EXTRACT"
   echo "cd PATCH_TARGET_DIR=$PATCH_TARGET_DIR"
   cd "$PATCH_TARGET_DIR"

   if [ $NEED_TAR_EXTRACT -eq 1 ]; then
      commit_git "." "ORIGINAL: extracted archive" ""
      if [ $? -ne 0 ]; then
         echo "ERROR: $FUNCNAME (${LINENO}): commit_git failed (post tarball extracted) while extracting '$TAR'"
         cd $ORIG_DIR
         return 1
      fi
   fi

   echo "PATCH_TARGET_DIR=$PATCH_TARGET_DIR" > $OUTPUT_FILE
   echo "EXCLUDE_PATCH_NUM_CSV=$EXCLUDE_PATCH_NUM_CSV" >> $OUTPUT_FILE
   echo "METHOD=$METHOD" >> $OUTPUT_FILE
   echo "RAW_SCRIPT=$RAW_SCRIPT" >> $OUTPUT_FILE
   echo "RPMBUILD_BUILD_DIR=$RPMBUILD_BUILD_DIR" >> $OUTPUT_FILE
   return 0
}

tar_and_spec_extract_to_git () {
   local SPEC_PATH=$1
   local WRS_PKG_DIR=$2
   local ROOT_DIR=$3
   local BUILD_DIR=$4
   local BRANCH=$5
   local NO_META_PATCH=$6
   local TIS_PATCH_VER=$7
   local USE_GIT=1
   local TARGET_ARCH=x86_64

   if [ ! -f $SPEC_PATH ]; then
      echo "ERROR: $FUNCNAME (${LINENO}): spec not found '$SPEC_PATH'"
      return 1
   fi

   local ORIG_DIR=$(pwd)

   if [ "x$ROOT_DIR" == "x" ]; then
      ROOT_DIR="$MY_WORKSPACE/srpm_work"
   fi

   if [ "x$BUILD_DIR" == "x" ]; then
      BUILD_DIR="$PKG_DIR/rpmbuild"
   fi

   if [ "x$BRANCH" == "x" ]; then
      BRANCH="work"
   fi

   local SPEC_DIR="$ROOT_DIR/$BUILD_DIR/SPECS"
   local SOURCE_DIR="$ROOT_DIR/$BUILD_DIR/SOURCES"
   local GIT_DIR="$ROOT_DIR/$(dirname $BUILD_DIR)/gits"
   local PATCH_TARGET_DIR
   local META_PATCH_TARGET_DIR="$ROOT_DIR/$BUILD_DIR"
   local ARCH=centos
   local ORIG_BRANCH=""
   local PRE_WRS_PREFIX="pre_wrs_"
   local WRS_POST_COPY_PREFIX="wrs_post_copy_list_"
   local PRE_WRS_TAG="$PRE_WRS_PREFIX$BRANCH"
   local WRS_POST_COPY_TAG="$WRS_POST_COPY_PREFIX$BRANCH"
   local ORIG_PRE_WRS_TAG=""
   local THIS_FUNC

   if [ "x$WRS_PKG_DIR" != "x" ]; then
      if [ ! -d $WRS_PKG_DIR ]; then
          echo "ERROR: $FUNCNAME (${LINENO}): WRS_PKG_DIR not found '$WRS_PKG_DIR'"
          return 1
      fi
   fi

   if [ ! -d $ROOT_DIR ]; then
      mkdir -p "$ROOT_DIR"
   fi

   if [ ! -d $ROOT_DIR/$BUILD_DIR ]; then
      mkdir -p "$ROOT_DIR/$BUILD_DIR"
   else
      if [ "x$NO_META_PATCH" != "x1" ]; then
          echo ""
          echo "Warning: Refusing to overwrite pre-existing edit environment for '$PKG_DIR'."
          echo "         To delete the old edit environment use:   --edit --clean <PKG>"
          return 2
      fi
   fi

   prep_git_for_metadata "$ROOT_DIR/$BUILD_DIR" "$BRANCH" $NO_META_PATCH "$PRE_WRS_PREFIX"
   if [ $? -ne 0 ]; then
      echo "ERROR: $FUNCNAME (${LINENO}): 'prep_git_for_metadata' failed while extracting '$SPEC_PATH'"
      cd $ORIG_DIR
      return 1
   fi

   # Copy SPEC and TAR
   mkdir -p "$SPEC_DIR"
   if [ $? -ne 0 ]; then
       echo "ERROR: $FUNCNAME (${LINENO}): Failed to create directory '$SPEC_DIR'"
       return 1
   fi

   mkdir -p "$SOURCE_DIR"
   if [ $? -ne 0 ]; then
       echo "ERROR: $FUNCNAME (${LINENO}): Failed to create directory '$SOURCE_DIR'"
       return 1
   fi

   cp -f "$SPEC_PATH" "$SPEC_DIR"
   if [ $? -ne 0 ]; then
       echo "ERROR: $FUNCNAME (${LINENO}): Failed to copy '$SPEC_PATH' to '$SPEC_DIR'"
       return 1
   fi

   # Add and Commit
   commit_git "$ROOT_DIR/$BUILD_DIR" "WRS: spec file" "$PRE_WRS_TAG"
   if [ $? -ne 0 ]; then
      echo "ERROR: $FUNCNAME (${LINENO}): commit_git failed while extracting '$SPEC_PATH'"
      cd $ORIG_DIR
      return 1
   fi


   local SPEC_GIT
   local PKG_NAME
   local PKG_VER
   local TAR_DIR
   local TAR
   local SOURCE_NO
   local SOURCE_NAME
   local PATCH_NO
   local PATCH_NAME
   local NUM_TAR
   local TAR_LIST


   for SPEC in $(cd $SPEC_DIR; ls -1 *.spec); do
      echo $SPEC;
      SPEC_GIT="$GIT_DIR/$SPEC"
      PKG_NAME=$(spec_find_tag Name $SPEC_DIR/$SPEC 2>> /dev/null)
      PKG_VER=$(spec_find_tag Version $SPEC_DIR/$SPEC 2>> /dev/null)
      TAR_DIR="$PKG_NAME-$PKG_VER"
      echo "   $TAR_DIR"

      local TAR_HAS_CHANGED

      TAR_HAS_CHANGED=1

      # Copy content from COPY_LIST if defined
      if [ "x$COPY_LIST" != "x" ]; then
         echo "COPY_LIST: $COPY_LIST"
         cd $WRS_PKG_DIR
         for p in $COPY_LIST; do
            echo "COPY_LIST: $p"
            \cp -L -f -r -v $p $META_PATCH_TARGET_DIR/SOURCES
            if [ $? -ne 0 ]; then
               echo "ERROR: COPY_LIST: file not found: '$p'"
               cd $ORIG_DIR
               return 1
            fi
         done

         cd - >> /dev/null

         # Add and Commit
         commit_git "$META_PATCH_TARGET_DIR" "WRS: COPY_LIST content" "$WRS_POST_COPY_TAG"
         if [ $? -ne 0 ]; then
            echo "ERROR: $FUNCNAME (${LINENO}): commit_git failed while extracting '$SPEC_PATH'"
            cd $ORIG_DIR
            return 1
         fi
      fi

      local PATCH_TARGET_DIR=""
      local EXCLUDE_PATCH_NUM_CSV=""
      local METHOD=""
      local RAW_SCRIPT=""
      local RPMBUILD_BUILD_DIR=""
      local OUTPUT_FILE="$ROOT_DIR/$PKG_DIR/tarball_extract_result"

      tarball_extract  "$SPEC_DIR"  "$SPEC"  "$SPEC_GIT"  "$SOURCE_DIR"  "$BRANCH"  "$ORIG_BRANCH"  "$TAR_DIR"  "$ROOT_DIR"  "$PKG_DIR"  "$BUILD_DIR"  "$TARGET_ARCH"  "$TIS_PATCH_VER"  "$OUTPUT_FILE"
      if [ $? -ne 0 ]; then
         echo "ERROR: $FUNCNAME (${LINENO}): tarball_extract failed while extracting '$SPEC_PATH'"
         cd $ORIG_DIR
         return 1
      fi

      source $OUTPUT_FILE

      # Apply patches named in spec file.
      echo "srpm_apply_spec_patches '$SPEC_DIR/$SPEC' '$SOURCE_DIR' '$PATCH_TARGET_DIR' '$EXCLUDE_PATCH_NUM_CSV' $USE_GIT '' '$METHOD' '$RAW_SCRIPT' '$ROOT_DIR' '$RPMBUILD_BUILD_DIR'  '$SPEC_GIT' '$BRANCH'"
      srpm_apply_spec_patches "$SPEC_DIR/$SPEC" "$SOURCE_DIR" "$PATCH_TARGET_DIR" "$EXCLUDE_PATCH_NUM_CSV" $USE_GIT "" $METHOD "$RAW_SCRIPT" "$ROOT_DIR" "$RPMBUILD_BUILD_DIR"  "$SPEC_GIT" "$BRANCH"
      if [ $? -ne 0 ]; then
         echo "ERROR: $FUNCNAME (${LINENO}): srpm_apply_spec_patches failed while extracting '$SPEC_PATH'"
         cd $ORIG_DIR
         return 1
      fi

   done

}



srpm_extract_to_git () {
   local ORIG_SRPM_PATH=$1
   local WRS_PKG_DIR=$2
   local ROOT_DIR=$3
   local BUILD_DIR=$4
   local BRANCH=$5
   local NO_META_PATCH=$6
   local TIS_PATCH_VER=$7
   local USE_GIT=1
   local TARGET_ARCH=x86_64

   if [ ! -f $ORIG_SRPM_PATH ]; then
      echo "ERROR: $FUNCNAME (${LINENO}): srpm not found '$ORIG_SRPM_PATH'"
      return 1
   fi

   local ORIG_DIR=$(pwd)
   local PKG_DIR=$(rpm -q --queryformat '%{NAME}\n' --nosignature -p $ORIG_SRPM_PATH)

   if [ "x$ROOT_DIR" == "x" ]; then
      ROOT_DIR="$MY_WORKSPACE/srpm_work"
   fi

   if [ "x$BUILD_DIR" == "x" ]; then
      BUILD_DIR="$PKG_DIR/rpmbuild"
   fi

   if [ "x$BRANCH" == "x" ]; then
      BRANCH="work"
   fi

   local SPEC_DIR="$ROOT_DIR/$BUILD_DIR/SPECS"
   local SOURCE_DIR="$ROOT_DIR/$BUILD_DIR/SOURCES"
   local GIT_DIR="$ROOT_DIR/$(dirname $BUILD_DIR)/gits"
   local PATCH_TARGET_DIR
   local META_PATCH_TARGET_DIR="$ROOT_DIR/$BUILD_DIR"
   local ARCH=centos
   local ORIG_BRANCH=""
   local PRE_WRS_PREFIX="pre_wrs_"
   local WRS_POST_COPY_PREFIX="wrs_post_copy_list_"
   local PRE_WRS_TAG="$PRE_WRS_PREFIX$BRANCH"
   local WRS_POST_COPY_TAG="$WRS_POST_COPY_PREFIX$BRANCH"
   local ORIG_PRE_WRS_TAG=""
   local THIS_FUNC


   if [ "x$WRS_PKG_DIR" != "x" ]; then
      if [ ! -d $WRS_PKG_DIR ]; then
          echo "ERROR: $FUNCNAME (${LINENO}): WRS_PKG_DIR not found '$WRS_PKG_DIR'"
          return 1
      fi
   fi

   if [ ! -d $ROOT_DIR ]; then
      mkdir -p "$ROOT_DIR"
   fi

   if [ ! -d $ROOT_DIR/$BUILD_DIR ]; then
      mkdir -p "$ROOT_DIR/$BUILD_DIR"
   else
      if [ "x$NO_META_PATCH" != "x1" ]; then
          echo ""
          echo "Warning: Refusing to overwrite pre-existing edit environment for '$PKG_DIR'."
          echo "         To delete the old edit environment use:   --edit --clean <PKG>"
          return 2
      fi
   fi

   prep_git_for_metadata "$ROOT_DIR/$BUILD_DIR" "$BRANCH" $NO_META_PATCH "$PRE_WRS_PREFIX"
   if [ $? -ne 0 ]; then
      echo "ERROR: $FUNCNAME (${LINENO}): prep_git_for_metadata failed while extracting '$ORIG_SRPM_PATH'"
      cd $ORIG_DIR
      return 1
   fi

   # Extract src.rpm
   echo "rpm -i --nosignature --root=$ROOT_DIR --define='%_topdir $BUILD_DIR' $ORIG_SRPM_PATH"
   rpm -i --nosignature --root=$ROOT_DIR --define="%_topdir $BUILD_DIR" $ORIG_SRPM_PATH
   if [ $? -ne 0 ]; then
       echo "ERROR: $FUNCNAME (${LINENO}): Failed to extract '$ORIG_SRPM_PATH' to '$ROOT_DIR/$BUILD_DIR'"
       return 1
   fi

   # Add and Commit
   commit_git "$ROOT_DIR/$BUILD_DIR" "ORIGINAL: srpm extract" "$PRE_WRS_TAG"
   if [ $? -ne 0 ]; then
      echo "ERROR: $FUNCNAME (${LINENO}): commit_git failed while extracting '$ORIG_SRPM_PATH'"
      cd $ORIG_DIR
      return 1
   fi

   local SPEC_GIT
   local PKG_NAME
   local PKG_VER
   local TAR_DIR
   local TAR
   local SOURCE_NO
   local SOURCE_NAME
   local PATCH_NO
   local PATCH_NAME
   local NUM_TAR
   local TAR_LIST


   for SPEC in $(cd $SPEC_DIR; ls -1 *.spec); do
      echo $SPEC;
      SPEC_GIT="$GIT_DIR/$SPEC"
      PKG_NAME=$(srpm_spec_find_name $SPEC_DIR/$SPEC 2>> /dev/null)
      PKG_VER=$(srpm_spec_find_version $SPEC_DIR/$SPEC 2>> /dev/null)
      TAR_DIR="$PKG_NAME-$PKG_VER"
      echo "   $TAR_DIR"

      local TAR_HAS_CHANGED

      TAR_HAS_CHANGED=1

      local PATCH_TARGET_DIR=""
      local EXCLUDE_PATCH_NUM_CSV=""
      local METHOD=""
      local RAW_SCRIPT=""
      local RPMBUILD_BUILD_DIR=""
      local OUTPUT_FILE="$ROOT_DIR/$PKG_DIR/tarball_extract_result"

      tarball_extract  "$SPEC_DIR"  "$SPEC"  "$SPEC_GIT"  "$SOURCE_DIR"  "$BRANCH"  "$ORIG_BRANCH"  "$TAR_DIR"  "$ROOT_DIR"  "$PKG_DIR"  "$BUILD_DIR"  "$TARGET_ARCH"  "$TIS_PATCH_VER" "$OUTPUT_FILE" "$NO_META_PATCH"
      if [ $? -ne 0 ]; then
         echo "ERROR: $FUNCNAME (${LINENO}): tarball_extract failed while extracting '$ORIG_SRPM_PATH'"
         cd $ORIG_DIR
         return 1
      fi

      source $OUTPUT_FILE

      # Apply patches named in original spec file... before our meta patches
      echo "srpm_apply_spec_patches '$SPEC_DIR/$SPEC' '$SOURCE_DIR' '$PATCH_TARGET_DIR' '$EXCLUDE_PATCH_NUM_CSV' $USE_GIT 'ORIGINAL: ' '$METHOD' '$RAW_SCRIPT' '$ROOT_DIR' '$RPMBUILD_BUILD_DIR'  '$SPEC_GIT' '$BRANCH'"
      srpm_apply_spec_patches "$SPEC_DIR/$SPEC" "$SOURCE_DIR" "$PATCH_TARGET_DIR" "$EXCLUDE_PATCH_NUM_CSV" $USE_GIT "ORIGINAL: " $METHOD "$RAW_SCRIPT" "$ROOT_DIR" "$RPMBUILD_BUILD_DIR"  "$SPEC_GIT" "$BRANCH"
      if [ $? -ne 0 ]; then
         cd $ORIG_DIR
         echo "ERROR: $FUNCNAME (${LINENO}): srpm_apply_spec_patches failed while extracting '$ORIG_SRPM_PATH'"
         return 1
      fi

      if [ "$GLOBAL_PATCH_TARGET_DIR" != "$PATCH_TARGET_DIR" ]; then
         echo "changing PATCH_TARGET_DIR from $PATCH_TARGET_DIR to $GLOBAL_PATCH_TARGET_DIR"
         PATCH_TARGET_DIR="$GLOBAL_PATCH_TARGET_DIR"
      fi
      cd $PATCH_TARGET_DIR

      # Verify we are on the correct branch
      CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
      if [ "$CURRENT_BRANCH" != "$BRANCH" ]; then
         echo "git checkout -b $BRANCH"
         git checkout -b $BRANCH
         if [ $? -ne 0 ]; then
            echo "ERROR: $FUNCNAME (${LINENO}): failed to create branch '$BRANCH'"
            cd $ORIG_DIR
            return 1
         fi
      fi

      # Tag the pre-wrs-patches contents
      git tag $PRE_WRS_TAG
      if [ $? -ne 0 ]; then
         echo "ERROR: $FUNCNAME (${LINENO}): 'git tag' failed for 'rpmbuild'"
         cd $ORIG_DIR
         return 1
      fi

      # Copy content from COPY_LIST if defined
      if [ "x$COPY_LIST" != "x" ]; then
         echo "COPY_LIST: $COPY_LIST"
         cd $WRS_PKG_DIR
         for p in $COPY_LIST; do
            echo "COPY_LIST: $p"
            \cp -L -f -r -v $p $META_PATCH_TARGET_DIR/SOURCES
            if [ $? -ne 0 ]; then
               echo "ERROR: $FUNCNAME (${LINENO}): COPY_LIST: file not found: '$p'"
               cd $ORIG_DIR
               return 1
            fi
         done

         cd - >> /dev/null

         # Add and Commit
         commit_git "$META_PATCH_TARGET_DIR" "WRS: COPY_LIST content" "$WRS_POST_COPY_TAG"
         if [ $? -ne 0 ]; then
            echo "ERROR: $FUNCNAME (${LINENO}): commit_git failed while extracting '$ORIG_SRPM_PATH'"
            cd $ORIG_DIR
            return 1
         fi
      fi

      # Apply WRS patches
      if [ "x$NO_META_PATCH" != "x1" ]; then
         if [ "x$WRS_PKG_DIR" != "x" ]; then
            # Apply wrs patches to spec file and other meta-data
            echo "srpm_apply_meta_patches '$META_PATCH_TARGET_DIR' '$WRS_PKG_DIR' $USE_GIT '$ARCH' '$BRANCH'"
            srpm_apply_meta_patches "$META_PATCH_TARGET_DIR" "$WRS_PKG_DIR" $USE_GIT "$ARCH" "$BRANCH"
            if [ $? -ne 0 ]; then 
               cd $ORIG_DIR
               return 1
            fi

            RAW_SCRIPT=$ROOT_DIR/$PKG_DIR/raw_script2

            local RPMBUILD_BUILD_DIR2=$ROOT_DIR/$BUILD_DIR/BUILD
            if [ -d "$RPMBUILD_BUILD_DIR2" ]; then
                echo "rm -rf RPMBUILD_BUILD_DIR2=$RPMBUILD_BUILD_DIR"
                \rm -rf "$RPMBUILD_BUILD_DIR2"
            fi
            mkdir -p $RPMBUILD_BUILD_DIR2

            echo "srpm_create_raw_extract_script '$SPEC_DIR/$SPEC' '$ROOT_DIR/$PKG_DIR'  '$ROOT_DIR/$BUILD_DIR'  '$TARGET_ARCH' '$TIS_PATCH_VER' '$RAW_SCRIPT'  '$TAR_DIR'"
            srpm_create_raw_extract_script "$SPEC_DIR/$SPEC" "$ROOT_DIR/$PKG_DIR"  "$ROOT_DIR/$BUILD_DIR"  "$TARGET_ARCH" "$TIS_PATCH_VER" "$RAW_SCRIPT"  "$TAR_DIR"
            if [ $? -ne 0 ]; then
               echo "ERROR: $FUNCNAME (${LINENO}): srpm_create_raw_extract_script post meta-patches failed"
               cd $ORIG_DIR
               return 1
            fi

            if [ -d "$RPMBUILD_BUILD_DIR2" ]; then
                echo "rm -rf RPMBUILD_BUILD_DIR2=$RPMBUILD_BUILD_DIR"
                \rm -rf "$RPMBUILD_BUILD_DIR2"
            fi
            mkdir -p $RPMBUILD_BUILD_DIR2

            EXTRACT_SCRIPT=$ROOT_DIR/$PKG_DIR/extract_script2
            echo "raw_create_tarballs_extract_script_post_metapatch '$RAW_SCRIPT'  '$EXTRACT_SCRIPT'  '$RPMBUILD_BUILD_DIR'  '$SPEC_GIT'"
            raw_create_tarballs_extract_script_post_metapatch "$RAW_SCRIPT"  "$EXTRACT_SCRIPT"  "$RPMBUILD_BUILD_DIR"  "$SPEC_GIT"
            if [ $? -ne 0 ]; then
                echo "ERROR: $FUNCNAME (${LINENO}): raw_create_tarballs_extract_script_post_metapatch failed"
                cd $ORIG_DIR
                return 1
            fi

            (
             source $EXTRACT_SCRIPT
             RC=$?
             echo "SRPM_EXTRACT_DIR=$(pwd)"
             exit $RC
            ) | tee $EXTRACT_SCRIPT.post.log
            if [ ${PIPESTATUS[0]} -ne 0 ] ; then
               echo "ERROR: $FUNCNAME (${LINENO}): Failed in script '$EXTRACT_SCRIPT'"
               cd $ORIG_DIR
               return 1
            fi


            # Apply wrs patches named in modified spec file. 
            echo "srpm_apply_spec_patches '$SPEC_DIR/$SPEC' '$SOURCE_DIR' '$PATCH_TARGET_DIR' '$EXCLUDE_PATCH_NUM_CSV' $USE_GIT 'WRS: ' '$METHOD' '$RAW_SCRIPT' '$ROOT_DIR' '$RPMBUILD_BUILD_DIR'  '$SPEC_GIT' '$BRANCH'"
            srpm_apply_spec_patches "$SPEC_DIR/$SPEC" "$SOURCE_DIR" "$PATCH_TARGET_DIR" "$EXCLUDE_PATCH_NUM_CSV" $USE_GIT "WRS: " $METHOD "$RAW_SCRIPT" "$ROOT_DIR" "$RPMBUILD_BUILD_DIR"  "$SPEC_GIT" "$BRANCH"
            if [ $? -ne 0 ]; then
               echo "ERROR: $FUNCNAME (${LINENO}): srpm_apply_spec_patches failed"
               cd $ORIG_DIR
               return 1
            fi
         fi
      fi

   done

   echo "Successfully extracted to: $BUILD_DIR"
   cd $ORIG_DIR
   return 0
}




srpm_apply_spec_patches () {
   local SPEC_PATH=${1}
   local PATCH_DIR=${2}
   local PATCH_TARGET_DIR=${3}
   local EXCLUDE_PATCH_NUM_CSV=${4}
   local USE_GIT=${5}
   local COMMEN_PREFIX=${6}
   local METHOD=${7}
   local RAW_SCRIPT=${8}
   local ROOT_DIR=${9}
   local RPMBUILD_BUILD_DIR=${10}  
   local SPEC_GIT=${11}
   local BRANCH=${12}


   local PATCH_NO 
   local PATCH_NAME 
   local PATCH 
   local PATCH_ARGS

   local ORIG_DIR=$(pwd)
   echo "Applying patches"

   if [ ! -f "$SPEC_PATH" ]; then
      echo "ERROR: $FUNCNAME (${LINENO}): Can't find spec file at '$SPEC_PATH'"
      return 1
   fi

   if [ ! -d "$PATCH_DIR" ]; then
      echo "ERROR: $FUNCNAME (${LINENO}): Patch directory not found '$PATCH_DIR'"
      return 1
   fi

   cd $PATCH_TARGET_DIR
   if [ $? -ne 0 ]; then
      echo "ERROR: $FUNCNAME (${LINENO}): Failed to cd to Target directory '$PATCH_TARGET_DIR'"
      return 1
   fi

   # Add patches
   local PL=""
   if [ "$METHOD" -eq $METHOD_RPMBUILD_SCRIPT ]; then
      PL=$(raw_patch_order $RAW_SCRIPT $SPEC_PATH)
      if [ $? -ne 0 ];then
         echo "ERROR: $FUNCNAME (${LINENO}): raw_patch_order failed on RAW_SCRIPT=$RAW_SCRIPT"
         return 1
      fi
   else
      grep '^%patch[0-9]* ' $SPEC_PATH > /dev/null
      if [ $? -eq 0 ];then
         echo "Using '%patch' method"
         PL=$(grep '^%patch[0-9]* ' $SPEC_PATH | awk  '{print $1}' | sed 's/^%patch//')
      else
         grep '^git am' $SPEC_PATH > /dev/null
         if [ $? -eq 0 ];then
            echo "Using 'git am' method"
            PL=$(grep -i '^[Pp]atch[0-9]*:' $SPEC_PATH | awk -F : '{print $1}' | sed 's/^[Pp]atch//' | sort  --unique --version-sort)
         else
            grep '^xargs git am' $SPEC_PATH > /dev/null
            if [ $? -eq 0 ];then
               echo "Using 'xargs git am' method"
               PL=$(grep -i '^[Pp]atch[0-9]*:' $SPEC_PATH | awk -F : '{print $1}' | sed 's/^[Pp]atch//' | sort  --unique --version-sort)
            else
               echo "Warning: no known patch apply command"
            fi
         fi
      fi
   fi

   local PATCH_COUNT
   if [ "x$PL" != "x" ];then
      PATCH_COUNT=0
      for PATCH_NO in $PL ; do
         PATCH_COUNT=$((PATCH_COUNT + 1))
         local EXCLUDED=0
         for EXCLUDE_PATCH_NO in $(echo $EXCLUDE_PATCH_NUM_CSV | tr ',' ' '); do
             if [ $EXCLUDE_PATCH_NO == $PATCH_NO ]; then
                 EXCLUDED=1
                 break
             fi
         done

         if [ $EXCLUDED -eq 1 ]; then
            echo "   Exclude Patch$PATCH_NO"
            continue
         fi

         local PATCH_NM
         PATCH_NM="Patch$PATCH_NO"
         echo "   $PATCH_NM"

         if [ "$METHOD" -eq $METHOD_RPMBUILD_SCRIPT ]; then
            PATCH_NAME=$(raw_extract_patch_file $RAW_SCRIPT $PATCH_NO $SPEC_PATH)
         else
            PATCH_NAME=$(spec_find_tag $PATCH_NM $SPEC_PATH 2>> /dev/null | awk -F / '{print $NF}')
            if [ "x$PATCH_NAME" == "x" ]; then
               PATCH_NM="patch$PATCH_NO"
               echo "   $PATCH_NM"
               PATCH_NAME=$(spec_find_tag $PATCH_NM $SPEC_PATH 2>> /dev/null | awk -F / '{print $NF}')
            fi
         fi

         echo "      $PATCH_NAME"
         PATCH="$PATCH_DIR/$PATCH_NAME"

         if [ "$METHOD" -eq $METHOD_RPMBUILD_SCRIPT ]; then
            PATCH_ARGS="-p1"
         else
            PATCH_ARGS=$(spec_find_patch_args "$PATCH_NM" "$SPEC_PATH")
         fi

         echo "srpm_apply_patch '$PATCH' '$PATCH_ARGS' '$PATCH_TARGET_DIR' '$USE_GIT' '$COMMEN_PREFIX$PATCH_NM: ' '$METHOD' '$RAW_SCRIPT' '$ROOT_DIR' '$RPMBUILD_BUILD_DIR' '$SPEC_GIT' '$PATCH_NO' '$BRANCH' '$SPEC_PATH' '$PATCH_COUNT'"
         srpm_apply_patch "$PATCH" "$PATCH_ARGS" "$PATCH_TARGET_DIR" $USE_GIT "$COMMEN_PREFIX$PATCH_NM: " $METHOD "$RAW_SCRIPT" "$ROOT_DIR" "$RPMBUILD_BUILD_DIR" "$SPEC_GIT" "$PATCH_NO" "$BRANCH" "$SPEC_PATH" $PATCH_COUNT
         if [ $? -ne 0 ]; then
            echo "ERROR: $FUNCNAME (${LINENO}): failed to apply patch '$PATCH'"
            cd $ORIG_DIR
            return 1
         fi
      done
   fi

   cd $ORIG_DIR
   return 0
}



srpm_apply_patch() {
   local PATCH="${1}"
   local PATCH_ARGS="${2}"
   local TARGET_DIR="${3}"
   local USE_GIT="${4}"
   local COMMENT_PREFIX="${5}"
   local METHOD=${6}
   local RAW_SCRIPT=${7}
   local ROOT_DIR=${8}
   local RPMBUILD_BUILD_DIR=${9}
   local SPEC_GIT=${10}
   local PATCH_NO="${11}"
   local BRANCH="${12}"
   local SPEC_PATH="${13}"
   local PATCH_COUNT_TARGET="${14}"


   # echo "srpm_apply_patch: PATCH=$PATCH  PATCH_ARGS=$PATCH_ARGS  TARGET_DIR=$TARGET_DIR  USE_GIT=$USE_GIT  COMMENT_PREFIX=$COMMENT_PREFIX  METHOD=$METHOD  RAW_SCRIPT=$RAW_SCRIPT  ROOT_DIR=$ROOT_DIR  RPMBUILD_BUILD_DIR=$RPMBUILD_BUILD_DIR  SPEC_GIT=$SPEC_GIT  PATCH_NO=$PATCH_NO"
   local ORIG_DIR
   ORIG_DIR=$(pwd)

   if [ ! -f $PATCH ]; then
      echo "ERROR: $FUNCNAME (${LINENO}): Patch '$PATCH' not found"
      return 1
   fi

   if [ "x$TARGET_DIR" == "x" ]; then
      TARGET_DIR="$ORIG_DIR"
   fi

   if [ ! -d $TARGET_DIR ]; then
      echo "ERROR: $FUNCNAME (${LINENO}): Directory '$TARGET_DIR' not found"
      return 1
   fi

   if [ $USE_GIT -gt 0 ]; then
      if [ ! -d "$TARGET_DIR/.git" ] && [ ! -d "$TARGET_DIR/../.git" ]; then
         echo "ERROR: $FUNCNAME (${LINENO}): Directory '$TARGET_DIR' is not managed by git"
         return 1
      fi
   fi

   cd "$TARGET_DIR"
   if [ $? -ne 0 ]; then
      echo "ERROR: $FUNCNAME (${LINENO}): Failed to cd to '$TARGET_DIR'"
      return 1
   fi

   local TAG="v$BRANCH"
   local PFN=$(basename $PATCH)

   local MSG="$PFN"
   local HASH=""
   local ADD_OUT
   local ADD_WC

   if [ $USE_GIT -gt 0 ]; then
      HASH=$(git log --pretty=format:'%H' --grep="$MSG\$")
   fi

   if [ "x$HASH" == "x" ]; then
      if [ $USE_GIT -gt 0 ]; then
         # Verify we are on the correct branch
         CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
         if [ "$CURRENT_BRANCH" != "$BRANCH" ]; then
            echo "git checkout $TAG"
            git checkout $TAG
            if [ $? -ne 0 ]; then
               echo "ERROR: $FUNCNAME (${LINENO}): failed to checkout tag '$TAG'"
            fi

            echo "git checkout -b $BRANCH"
            git checkout -b $BRANCH
            if [ $? -ne 0 ]; then
               echo "ERROR: $FUNCNAME (${LINENO}): failed to create branch '$BRANCH'"
               cd $ORIG_DIR
               return 1
            fi
         fi
      fi

      if [ $METHOD -eq $METHOD_RPMBUILD_SCRIPT ]; then
         local PATCH_SCRIPT=$(dirname $RAW_SCRIPT)/patch_script
         echo "raw_create_patch_apply_script   $RAW_SCRIPT  $PATCH_NO $PATCH_SCRIPT  $RPMBUILD_BUILD_DIR  $SPEC_GIT  $SPEC_PATH  $PATCH_COUNT_TARGET"
         raw_create_patch_apply_script   $RAW_SCRIPT  $PATCH_NO $PATCH_SCRIPT  $RPMBUILD_BUILD_DIR  $SPEC_GIT  $SPEC_PATH $PATCH_COUNT_TARGET
         if [ $? -ne 0 ]; then
            echo "ERROR: $FUNCNAME (${LINENO}): raw_create_patch_apply_script failed"
            cd $ORIG_DIR
            return 1
         fi

         if [ -f $PATCH_SCRIPT ]; then
            echo "source $PATCH_SCRIPT"
            (
             source $PATCH_SCRIPT
            )
            if [ $? -ne 0 ]; then
               echo "ERROR: $FUNCNAME (${LINENO}): Failed to apply patch '$PATCH' using script '$PATCH_SCRIPT'"
               return 1
            fi
         else
            echo "ERROR: $FUNCNAME (${LINENO}): file not found at PATCH_SCRIPT=$PATCH_SCRIPT"
            cd $ORIG_DIR
            return 1
         fi
      else
         echo "patch $PATCH_ARGS < $PATCH"
         patch -f $PATCH_ARGS --no-backup-if-mismatch < $PATCH
         if [ $? -ne 0 ]; then
            echo "failed to apply patch '$PATCH'"
            return 1
         fi
      fi

      if [ $PWD = $HOME ]; then
          echo "DPENNEY: in the home dir somehow"
          return 1
      fi

      if [ $? -eq 0 ]; then
         if [ $USE_GIT -gt 0 ]; then
            ADD_OUT=$(git add --all --verbose)
            if [ $? -ne 0 ]; then
               echo "ERROR: $FUNCNAME (${LINENO}): 'git add' failed for patch '$PATCH' of '$SPEC' while extracting '$ORIG_SRPM_PATH'"
               cd $ORIG_DIR
               return 1
            fi

            ADD_WC=$(git status porcelain | wc -l)
            if [ $ADD_WC -gt 0 ]; then
               # The kernel-rt has an empty "test patch", so use --allow-empty
               git commit --allow-empty -m "$COMMENT_PREFIX$PFN"
               if [ $? -ne 0 ]; then
                  echo "ERROR: $FUNCNAME (${LINENO}): 'git commit' failed for patch '$PATCH' of '$SPEC' while extracting '$ORIG_SRPM_PATH'"
                  cd $ORIG_DIR
                  return 1
               fi
            fi
         fi
      else
         echo "ERROR: $FUNCNAME (${LINENO}): Failed patch: $MSG"
         cd $ORIG_DIR
         return 1
      fi
   else
      echo "Patch already applied: $MSG"
      if [ $USE_GIT -gt 0 ]; then
         git tag -d $TAG
         git tag $TAG $HASH
         echo "git tag $TAG $HASH == $?"
      fi
   fi

   cd $ORIG_DIR
   return 0
}


srpm_find_tag () {
   local TAG=$1
   local SRPM_FILE=$2

   local VALUE=$(rpm -q --queryformat "%{$TAG}\n" --nosignature -p $SRPM_FILE)
   if [ $? -ne 0 ]; then
      echo ""
      return 1
   fi

   echo "$VALUE"
   return 0
}


srpm_list_packages () {
   local SRPM_FILE=$1

   local TMPDIR=$(mktemp -d /tmp/srpm_list_packages_XXXXXX)

   (
    cd $TMPDIR &>> /dev/null
    # rpm2cpio $SRPM_FILE | cpio -civ '*.spec' &>> /dev/null
    rpm -i --root=$TMPDIR --nosignature $SRPM_FILE
   )

   for SPEC in $(find $TMPDIR -name '*.spec' | sort -V); do
      spec_list_packages $SPEC
   done
    
   \rm -rf $TMPDIR &>> /dev/null
}


srpm_list_versioned_packages () {
   local SRPM_FILE=$1

   local TMPDIR=$(mktemp -d /tmp/srpm_list_packages_XXXXXX)

   (
    cd $TMPDIR &>> /dev/null
    # rpm2cpio $SRPM_FILE | cpio -civ '*.spec' &>> /dev/null
    rpm -i --root=$TMPDIR --nosignature $SRPM_FILE
   )

   for SPEC in $(find $TMPDIR -name '*.spec' | sort -V); do
      spec_list_versioned_packages $SPEC
   done

   \rm -rf $TMPDIR &>> /dev/null
}


srpm_list_ver_rel_packages () {
   local SRPM_FILE=$1 
   
   local TMPDIR=$(mktemp -d /tmp/srpm_list_packages_XXXXXX)
   
   (
    cd $TMPDIR &>> /dev/null
    # rpm2cpio $SRPM_FILE | cpio -civ '*.spec' &>> /dev/null
    rpm -i --root=$TMPDIR --nosignature $SRPM_FILE
   )         
   
   for SPEC in $(find $TMPDIR -name '*.spec' | sort -V); do
      spec_list_ver_rel_packages $SPEC
   done  

   \rm -rf $TMPDIR &>> /dev/null
}


srpm_list_ver_rel_arch_packages () {
   local SRPM_FILE=$1 
   
   local TMPDIR=$(mktemp -d /tmp/srpm_list_packages_XXXXXX)
   
   (
    cd $TMPDIR &>> /dev/null
    # rpm2cpio $SRPM_FILE | cpio -civ '*.spec' &>> /dev/null
    rpm -i --root=$TMPDIR --nosignature $SRPM_FILE
   )         
   
   for SPEC in $(find $TMPDIR -name '*.spec' | sort -V); do
      spec_list_ver_rel_arch_packages $SPEC
   done  

   \rm -rf $TMPDIR &>> /dev/null
}


srpm_build_requires () {
   local SRPM_FILE=$1

   local TMPDIR=$(mktemp -d /tmp/srpm_list_packages_XXXXXX)

   (
    cd $TMPDIR &>> /dev/null
    # rpm2cpio $SRPM_FILE | cpio -civ '*.spec' &>> /dev/null
    rpm -i --root=$TMPDIR $SRPM_FILE
   )

   for SPEC in $(find $TMPDIR -name '*.spec' | sort -V); do
      spec_build_requires $SPEC
   done

   \rm -rf $TMPDIR &>> /dev/null
}


srpm_match_package_list () {
   local Aname=$1[@]
   local TARGET_LIST=("${!Aname}")
   local SRPM_FILE=$2
   local TARGET
   local PKG_NAME

   for PKG_NAME in $(srpm_list_packages "$SRPM_FILE"); do
       for TARGET in "${TARGET_LIST[@]}"; do
           if [ "$PKG_NAME" == "$TARGET" ]; then
               >&2 echo "found target '$TARGET' in file '$SRPM_FILE' as a package name"
               echo "$TARGET"
               return 0
           fi
       done
   done

   return 1
}

srpm_match_package () {
   local TARGET=$1
   local SRPM_FILE=$2
   local PKG_NAME

   for PKG_NAME in $(srpm_list_packages "$SRPM_FILE"); do
       if [ "$PKG_NAME" == "$TARGET" ]; then
           echo "found target '$TARGET' in file '$SRPM_FILE' as a package name"
           return 0
       fi
   done

   return 1
}


srpm_match_target_list () {
   local Aname=$1[@]
   local TARGET_LIST=("${!Aname}")
   local SRPM_FILE=$2
   local TARGET
   local NAME
   local SERVICE
   local PKG_NAME

   NAME=$(srpm_find_tag Name "$SRPM_FILE")
   if [ $? -eq 0 ]; then
       for TARGET in "${TARGET_LIST[@]}"; do
           if [ "$NAME" == "$TARGET" ]; then
               echo $TARGET
               return 0
           fi
           if [ "$BUILD_TYPE" == "rt" ]; then
               if [ "${NAME}-rt" == "$TARGET" ]; then
                   echo $TARGET
                   return 0
               fi
           fi
       done
   fi 

   SERVICE=$(srpm_find_tag Service "$SRPM_FILE")
   if [ $? -eq 0 ]; then
       for TARGET in "${TARGET_LIST[@]}"; do
           if [ "$SERVICE" == "$TARGET" ]; then
               echo $TARGET
               return 0
           fi
       done
   fi

   srpm_match_package_list TARGET_LIST "$SRPM_FILE"
   if [ $? -eq 0 ]; then
       return 0
   fi

   return 1
}

srpm_match_target () {
   local TARGET=$1
   local SRPM_FILE=$2
   local NAME
   local SERVICE
   local PKG_NAME

   NAME=$(srpm_find_tag Name "$SRPM_FILE")
   if [ $? -eq 0 ]; then
       if [ "$NAME" == "$TARGET" ]; then
           echo "found target '$TARGET' in file '$SRPM_FILE' as a name"
           return 0
       fi
   fi

   SERVICE=$(srpm_find_tag Service "$SRPM_FILE")
   if [ $? -eq 0 ]; then
       if [ "$SERVICE" == "$TARGET" ]; then
           echo "found target '$TARGET' in file '$SRPM_FILE' as a service"
           return 0
       fi
   fi

   srpm_match_package "$TARGET" "$SRPM_FILE"
   if [ $? -eq 0 ]; then
       return 0
   fi

   return 1
}

# The intent of this function is to calculate the number of commits between the
# base srcrev and the top-most commit.  This is only meant to be used at the
# top level of a subgit; not a subdirectory within a git tree.
#
srpm_git_revision_count () {
    local SRC_DIR=$1
    local BASE_SRCREV=$2

    pushd $SRC_DIR > /dev/null
    local COUNT=$(git rev-list --count $BASE_SRCREV..HEAD)
    if [ $? -ne 0 ]; then
        return 1
    fi
    local DIRTY=$(git status --porcelain | wc -l)
    if [ "$DIRTY" -ne 0 ]; then
        # add an extra value for uncommitted work.
        COUNT=$((COUNT+1))
    fi
    popd > /dev/null

    echo $COUNT
    return 0
}

srpm_source_build_data () {
   local DATA_FILE=$1
   if [ ! -f $DATA_FILE ]; then
       >&2 echo "ERROR: $FUNCNAME (${LINENO}): $DATA_FILE not found"
       return 1
   fi
   source $DATA_FILE

   # TIS_PATCH_VER is mandatory
   if [ -z "$TIS_PATCH_VER" ]; then
       >&2 echo "ERROR: $FUNCNAME (${LINENO}): TIS_PATCH_VER must be set in $DATA_FILE"
       return 1
   elif [[ "$TIS_PATCH_VER" == GITREVCOUNT* ]]; then
       # Calculate the patch version dynamically based on the number of commits
       # in the subgit.  This also supports adding a "+N" at the end to force
       # an additional increment (e.g., TIS_PATCH_VER=GITREVCOUNT+1)
       if [ -z "$TIS_BASE_SRCREV" ]; then
          >&2 echo "ERROR: $FUNCNAME (${LINENO}): TIS_BASE_SRCREV must be set in $DATA_FILE"
          return 1
       fi
       if [ ! -d "$SRC_DIR" ]; then
          >&2 echo "ERROR: $FUNCNAME (${LINENO}): SRC_DIR must specify a subgit root path"
          return 1
       fi
       TIS_PATCH_INC=${TIS_PATCH_VER//[A-Z \+]/}
       TIS_PATCH_VER=$(srpm_git_revision_count $SRC_DIR $TIS_BASE_SRCREV)
       if [ $? -ne 0 ] || [ "$TIS_PATCH_VER" == "" ]; then
          >&2 echo "ERROR: $FUNCNAME (${LINENO}): Invalid TIS_BASE_SRCREV '$TIS_BASE_SRCREV'"
          return 1
       fi
       if [[ "$TIS_PATCH_INC" =~ ^-?[0-9]+$ ]]; then
           TIS_PATCH_VER=$((TIS_PATCH_VER+${TIS_PATCH_INC}))
       fi
   fi

   return 0
}
